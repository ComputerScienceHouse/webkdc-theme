Overview:

	This document discusses some of the issues in implementing
the webkdc part of the Stanford Webauth V3 authentication system. 
The purpose of this part of the webauthv3 system is to obtain long lived
user credentials that can be used by the rest of the system 
to obtain short term credentials for a specific service. The protocol
is discussed in webkdc-protocol. 


Requirements:

	The basic requirement is to support the protocol, but
there are some additional usage requirements. 

	There needs to be more than one webKDC machine for 
load balancing and reliability requirements. 

	The credentials issued by any one of the webKDCs must
be useable at any other webKDCs. 

	The rough estimate of maximum load on the whole system
is 5 requests/sec. 

	The webKDC needs to be able to make authority decisions
on what tickets to provide based on the following criteria:

	1. Type of authentication (username/passwd vs tgt)
	2. User principal ( optional in first release )
	3. Requesting server
	4. Service principal requested. 

	The underlying connection protocol (i.e. ssl ) must provide
date security and integrity, but does not need to provide authentication.

	A very strong form of encryption is needed for encrypting/decrypting
the ticket granting tickets. 

	The encryption keys used for encrypting/decrypting the tgt's
must be changed on a regular basis. 

Design: 

Overall deamon:
	The daemon will be use SSL as the underlying connection
library. Given the long startup time of SSL, it is expected that
the daemon will be a forking server that supports multiple XML
exchanges over a single connection. There is no requirement that
the client attempt multiple connections, but it must be possible
in the server. I don't know enough about SSL start up to know
if the deamon must be standalone or can be run from inetd. 	

	(Outline of algorithm, brief mention of Session Struct) 

Session handling: 
	(detail session struct )

XML handling: 
	There are two popular and viable C options for xml 
parsing libraries, libxml2 and expat. Both are under the 
MIT distribution license. A third option would be to write
a custom parser. My opinion is that both these are way more
complex than what we need, but we should stick with a 
standard xml parser unless load testing is unacceptable. 
	There will be a tremendous overlap here between
the client and server parts, a common library would be
a big win. All parts of the system will require a base64
handling library. Standardizing this would all be a big
win. 

Credentials handling: 
	(Issues in dealing w/files)
	(Exact format of returned data )

Encryption Issues: 
	(Use AES)
	(How to form key hints)
	(How often to change keys?)
	(How to manage key rings?)
	

Overall client:

	XML Handling:

	API?:

	
