<HTML>
<TITLE>WebAuth V3 Technical Specification</TITLE>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000FF" VLINK="#990066" ALINK="#FF0000">

<H1><B>WebAuth V3 Technical Specification</B></H1>
<H4><b>DRAFT Version  0.92, Modified 11/27/02</b></H4>
<H2><B>Contents</B></H2>

<UL>
<LI><a href="#intro">Introduction</a></LI>
<UL>
  <LI><a href="#components">WebAuth Components</a>
  <UL>
    <LI><a href="#compua">User-Agent (UA)</LI>
    <LI><a href="#compwas">WebAuth-enabled Application Server (WAS)</LI>
    <LI><a href="#compwkdc">Web Key Distribution Server (WebKDC)</LI>
  </UL>
  <LI><a href="#tokens">WebAuth Tokens</a>
  <LI><a href="#keymgmt">Security Model and Key Management</a>
  <UL>
    <LI><a href="#kmsessionkeys">Distributing and Managing Session Keys</a></LI>
    <LI><a href="#kmprivatekeys">Distributing and Managing Private Keys</a></LI>
    <LI><a href="#kmpool">Supporting Server Pools</a></LI>
  </UL>
</UL
<LI><a href="#scenarios">WebAuth Usage Scenarios</a></LI>
<UL>
  <LI><a href="#sc1">Application Access, no tokens (Initial Sign-on)</a></LI>
  <LI><a href="#sc2">Application Access, app-token</a></LI>
  <LI><a href="#sc3">Application Access, no app-token, proxy-token (Single Sign-on) </a></LI>
  <LI><a href="#sc4">Application Access, no app-token, credentials required (Proxied Credentials)</a></LI>
  <LI><a href="#logout">Logging Out</a></LI>
</UL>
<LI><a href="#httpconv">WAS and WebKDC HTTP Conventions</a></LI>
<LI><a href="#xmlproto">WebKDC XML Protocol Definitions</a></LI>
<UL>
  <LI><a href="#xmlover">Overview</a></LI>
  <LI><a href="#xmlcom">Common Elements</a></LI>
  <LI><a href="#xmlcmd">Commands</a></LI>
  <UL>
     <LI><a href="#xmlgettokens">getTokens</a></LI>
     <LI><a href="#xmlrequesttoken">requestToken</a></LI>
  </UL>
  <LI><a href="#xmlpost">Posting XML to WebKDC</a></LI>
  <LI><a href="#xmlex">Examples</a></LI>
</UL>
<LI><a href="#tokenformat">Tokens</a></LI>
<UL>
  <LI><a href="#tokenencoding">Token Encoding</a></LI>
  <LI><a href="#tokenattrs">Assigned Token Attributes</a></LI>
  <LI><a href="#tokenspecific">Specific Token Encodings</a></LI>
  <UL>
     <LI><a href="#tokenwebkdcservice">webkdc-service-token</a></LI>
     <LI><a href="#tokenwebkdcproxy">webkdc-proxy-token</a></LI>
     <LI><a href="#tokenrequest">request-token</a></LI>
     <LI><a href="#tokenerror">error-token</a></LI>
     <LI><a href="#tokenid">id-token</a></LI>
     <LI><a href="#tokenproxy">proxy-token</a></LI>
     <LI><a href="#tokencred">credential-token</a></LI>
     <LI><a href="#tokenlogin">login-token</a></LI>
     <LI><a href="#tokenapp">app-token</a></LI>
  </UL>
</UL>

<LI><a href="#cookies">Cookie Conventions</a></LI>
<LI><a href="#apache">Apache Directives</a></LI>
</UL>


<H2><B>1. <a name="intro">Introduction</a></B></H2>

<H3>1.1 <a name="components">WebAuth Components</a></H3>
The WebAuth protocol involves interactions between three basic components:

<OL>
  <LI>User-Agent (UA)</LI>
  <LI>WebAuth-enabled Application Server (WAS)</LI>
  <LI>WebKDC</LI>
</OL>

The desired goal of the WebAuth protocol is that a WAS will be
able to securely identify a user accessing resources. It is also desired 
that single sign-on be achieved, so a user does not have to sign into each
application separately, unless an application requires it for security reasons.

The WAS can also choose to either trust the WebKDC to vouch for the identity
of a user, or it can request the WebKDC use an authenticator, such as a
Kerberos V5 service request (krb5_mk_req) that it can verify using its 
own Kerberos V5 identity.

<H4>1.1.1 <a name="compua">User-Agent (UA)</a></H4>
The User-Agent is a web browser that supports cookies. No plugins, Java, or
JavaScript are required. The UA will be redirected to the WebKDC
as requested to by a WAS.

<H4>1.1.2 <a name="compwas">WebAuth-enabled Application Server (WAS)</a></H4>

A WebAuth-enabled Application Server is an Apache 2.0 server configured
to run the WebAuth module. The WebAuth module will guard access to
protected resources as configured by the administrator and/or application
developer. If a user hasn't been identified yet (as determined by 
possessing a WAS cookie), they will be re-directed to the WebKDC,
otherwise access will be granted.

<p>All interactions between the UA and WAS <b>SHOULD</b> be SSL-protected, to
prevent cookies being disclosed to an eavesdropper that could use those
cookies to impersonate a user.

<p>Although support will initially be provided only for Apache 2.0, it
should be possible to support the protocol under other application servers,
such as a Java application server (not running under Apache), and other
servers like IIS. The protocol is also being designed so it doesn't require 
Kerberos V5 support, which should aid in making it flexible to port to 
other application servers, and support future standards as they arise.

<H4>1.1.3 <a name="compwkdc">WebKDC</a></H4>

The WebKDC is also an Apache 2.0 server, running a custom Apache module.

<p>All interactions between the UA and WebKDC <b>MUST</b> be
protected via SSL to prevent disclosure of passwords, as well as sensitive
data such as the tokens which are used to provide single sign-on and
access to application resources.

<p>The WebKDC will listen for two different type of requests, which will
most likely be distinguished by different URLs.

<p>The first type of request are those requests coming from a UA after
it has been redirected by a WAS. When the WebKDC receives one of these, 
it will first see if the request includes a cookie that contains cached
credentials. If the request contains a valid cookie, this cookie is used
to obtain a new credentials and the user is redirected back to the WAS.

<p>If the cookie is not present or has expired, then the user will
be prompted for their username and password. After submitting this
information back to the WebKDC, the WebKDC will then verify the
username and password, using the configured authenticated backend
(Kerberos V5 by default). The WebKDC will the generate two "tokens".
One is placed in a cookie scoped for the WebKDC and used to provide
single sign-on in future requests, and one that gets sent back to the
WAS, which will verify it upon receipt.

<p>The second type of the WebKDC handles consist of XML messages that 
get POSTed to the WebKDC via HTTPS directly from a WAS. These message
are used to request additional credentials for a user.

<p>The WebKDC is also responsible for ensuring that the server making a
request is authorized to make the request. For example, one WAS server
can't use a "token" that was created for use by another WAS server.

<H3>1.2 <a name="tokens">WebAuth Tokens</a></H3>

<p>Tokens provide a standard mechanism to exchange and store information 
that is cryptographically secure from both tampering and disclosure. 
Tokens also contain information such as creation times to help detect 
replays, and expiration times so data is never trusted/used forever. Tokens
also enable authentication of the servers using them.

<p>Tokens get transfered
between servers using URL query parameters, 
POST data, cookies, and XML documents. They are AES-encrypted using 
either a private key, or a shared session key. They also include
a SHA1 HMAC used to detect data modification/tampering.

<p>There are currently nine different type of tokens, which are
described in the following table.
<p>

<table border>
 <tr align=center>
  <th>Token Type</th>
  <th>Encrypted With</th>
  <th>Description</th>
 </tr>
<tr>
  <td>webkdc-service</td>
  <td>WebKDC's private AES-key</td>
  <td>
     The webkdc-service-token is used by WebAuth App Servers to communicate 
     with the WebKDC. It contains a session key that is shared between
     the WebKDC and the WAS.

<p>webkdc-service-tokens are created only by the WebKDC, and are used only
by a WAS.

  </td>
</tr>

<tr>
  <td>webkdc-proxy</td>
  <td>WebKDC's private AES-key</td>
  <td>

The webkdc-proxy-token contains a user's proxied credentials (K5/K4 tgt).
The WebKDC will only allow a webkdc-proxy-token to be used by the server 
it was originally generated for. The main use of a webkdc-proxy-token is 
by the WebKDC itself to implement single sign-on. Its secondary use is to 
allow WAS servers to request credential-tokens.
  </td>
</tr>

<tr>
  <td>request</td>
  <td>session-key</td>
  <td>

The request-token contains the request from a WAS for a token 
(usually an id-token) from the WebKDC. It is AES-encrypted in a 
session-key from a webkdc-service-token, and contains information like 
the return URL, type of token requested, etc. A webkdc-service-token
is always included along with a request-token.

  </td>
</tr>

<tr>
  <td>error</td>
  <td>session-key</td>
  <td>
The error-token is returned in the event of an unrecoverable error
that occurred while asking for a token with a request-token.
  </td>
</tr>

<tr>
  <td>id</td>
  <td>session-key</td>
  <td>
The id-token contains the identity of the user trying to access a resource.
The WAS will verify the id-token, then construct an app-token for future use.
  </td>
</tr>

<tr>
  <td>proxy</td>
  <td>session-key</td>
  <td>
The proxy-token is used to return a webkdc-proxy-token to a WAS.
It includes information about the webkdc-proxy-token, such as
its expiration, its type, etc.
  </td>
</tr>

<tr>
  <td>cred</td>
  <td>session-key</td>
  <td>
  The credential-token contains a user's credential (K5/K4 service ticket).
  </td>
</tr>

<tr>
  <td>login</td>
  <td>WebKDC's private AES-key</td>
  <td>
login-tokens are used by the WebKDC with the requestTokenRequest command.
They contain the user's username and password and are used to obtain
the inital webkdc-proxy-tokens.
  </td>
</tr>

<tr>
  <td>app</td>
  <td>WAS private AES-key</td>
  <td>
app-tokens are used by WAS servers to store data, such as the identity
of a user after it has been verified from an id-token, a proxy-token, 
or credentials for future use. 
  </td>
</tr>

</table>

<p>Their exact formats are discussed in detail at the end of this document.

<H3>1.3 <a name="keymgmt">Security Model and Key Management</a></H3>

<p>As mentioned in the previous section, tokens are at the heart of
the WebAuth security model. They are used to authenticate requests
and responses between servers, as well as protect data that is
stored in URLs and cookie data. Shared symmetric keys (session-keys)
are used to encrypt tokens between servers, and private keys are
used to encrypt tokens meant for a only a single server to decrypt.

<p>Also note that any tokens that appear in URLs are tokens that
are only valid for a short-period of time (5 minutes by default).

<p>Any attempt to re-use them after that will fail. If a user bookmarks a URL
with a token in it (or hits their "back" button) then one of three things can
happen:

<OL>
<LI> The user has a valid cookie. In this case, the token in the URL
     is ignored (but still stripped out from the URL before passing it
     to the app), so there is no problem.
</LI>
<LI> The user has no valid cookie, but the token in the URL is still 
valid. In this case, the user will get granted access, and a cookie
will be created. Note that this can only happen until the token
is no longer "fresh" (as mentioned, 5 minutes by default).
</LI>
<LI>
 The user has no valid cookie, and the token is too old. In this case,
 the user will be redirected to the login page is usual (the token will
 be stripped from the URL before the redirect).
</LI>
</OL


<H4>1.3.1 <a name="kmsessionkeys">Distributing and Managing Session Keys</a></H3>

<p>In order to exchange session-keys, a key distribution
protocol is needed.  For this purpose, we use Kerberos V5 and SSL to
bootstrap and get the session-keys. The WAS that needs
a session-key will post an XML <a href="#xmlgettokens">message</a> to 
the WebKDC requesting a service-token. This message contains the
result of krb5_mk_req call for the WebKDC's server principal, which
the WebKDC uses to authenticate the server making the request. The
WebKDC will then send back the service-token, and the session-key
that is encrypted (in the WebKDC's key) inside of the service-token.
The WAS will need both to make future requests to the WebKDC. The whole
transaction itself is protected with SSL.

<p>The thing to note here is that there are no long term keys stored
on the WebKDC itself other its own private key. Once the WAS obtains the 
service-token and session-key, it will cache them both until the 
service-token expires, which will most likely be 24 hours. Before 
the service-token expires, the WAS must request a new service-token.

<p>The protocol is also designed such that other authentication mechanisms
may be used to bootstrap, such as the GSS-API, or SSL client authentication
between servers.

<p>One potential issue here is that we are using weaker DES keys
(Kerberos V5 keytabs) to bootstrap into stronger AES keys. This issue
is partially mitigated by the use of SSL to further protect the
transaction. It was decided that this was acceptable in order to
keep the WebKDC stateless and to re-use the existing Kerberos V5 
infrastructure where possible.

<H4>1.3.2 <a name="kmprivatekeys">Distributing and Managing Private Keys</a></H3>

<p>Both the WebKDC and the WAS servers need private keys to encrypt
their tokens with. These keys will be randomly-generated 128-bit AES
keys (longer keys are supported if needed), that get stored in "key rings". 
The key ring is used to contain previously valid keys, currently 
valid keys, and keys that will be valid in the future. A command-line 
utility is provided to manage the key ring file.

<p>The key ring consists of a number
of entries, each of which contain the following information:

<pre>
  key type       Type of the key, AES is the only supported key type right now.
  key data       The binary data that makes up the key
  creation       Time the key was created
  valid_from     When the key becomes valid
  valid_till     When the key expires
</pre>

<p>Of note is the "valid_from" value. It is used to create post-dated keys
in the key ring, to allow for new keys to get generated and distributed
among a pool of servers (for load balancing/fail-over) in such a way that
all the keys can be updated before the key becomes valid.

<p>Initially key rings can be distributed using a mechanism like SSH,
though there will eventually be support within the WebAuth protocol
for distributing new key rings.

<p>Current thinking is that the private AES-keys will be changed
once a month, with new keys being generated and post-dated 48-72 
hours in advance of the current key's expiration. Servers that don't 
have a new key within this window before the current key expires can 
log errors and raise the attention of system administrators. Since
the previous key is still maintained in the key ring, the servers
will be able to continue and parse outstanding tokens encrypted
in the previous key until the the token expires.

<H4>1.3.3 <a name="kmpool">Supporting Server Pools</a></H3>

<p>In order to support server pools, we need to ensure that
any server that receives a token is able to decrypt and verify it. Note
that we are only talking about the WebAuth protocol here, applications
must solve their own issues when dealing with a pool of servers.

<p>For the WebKDC, all we need to do is distribute the key ring file
across all the WebKDCs, and having a posted-dated new key in the key ring
file makes this task easier.

<p>For the WAS, there are two issues. First, we also need to distribute
the key ring file so all WAS servers can decrypt their app-tokens. The
second issue, is how to deal with session-keys.

<p>Recall that responses from the WebKDC come back to the WAS encrypted
in the session-key, not the WAS server's private key. If the response
comes back to a different WAS server, it would not have the same session-key
that another WAS server had. One way to deal with session-keys would be to 
share the same service-token and session-key across all the servers. This
of course would be very painful and expensive to do.

<p>Another way to handle this is make sure that the return-url in the
request-token contains the real server's hostname/ip address as opposed
to the virtual/pool address. This solves the problem as the request always
comes back to WAS server that initiated the request. This approach
however might not work in all environments. For example, the real
app server's address may not be visible from outside the firewall.

<p>The most flexible solution is to allow WAS servers to include some
"state" or "context" in each request-token. The WebKDC would treat
this state as opaque data, and return it to the WAS server along with
the requested token. Note that it would be transmitted alongside the
returned token, not inside of it. Now, the WAS server would
create an app-token (which is encrypted in its private key), that
contains the session-key, and use this as the state it sends in the
request-token. The WebKDC return this state along with the response,
and the WAS can decrypt the state using its private key to get the
session-key.

<H2><B>2. <a name="scenarios">WebAuth Scenarios</a></B></H2>

<OL>
  <LI>Application Access, no tokens (Initial Sign-on)</LI>
  <LI>Application Access, app-token</LI>
  <LI>Application Access, no app-token, proxy-token (Single Sign-on) </LI>
  <LI>Application Access, no app-token, credentials required (Proxied Credentials)</LI>
  <LI>Logging Out</LI>
</OL>

<H3>2.1 <a name="sc1">Application Access, no tokens (Initial Sign-on)</a></H3>

In the first scenario we discuss what happens when a user
requests a webauth-protected resource and has not yet logged in.
i.e., there is no app-token present, and there is no proxy-token
present.

<p>

<pre>
  ---------------------------------------------------------------
      UA                 WAS            WebKDC
  ---------------------------------------------------------------

      request resource
  1.  -----------------> WAS

      redirect to WebKDC
  2.  <----------------- WAS

      request-token for id-token
  3.  -------------------------------> WebKDC

      login form gets sent back
  4.  <------------------------------- WebKDC

      login form gets posted
  5.  -------------------------------> WebKDC

      confirmation page gets sent back
  6.  <------------------------------- WebKDC

      re-request resource (with returned token in URL)
  7.  -----------------> WAS

      set the app-token cookie, response from app 
  8.  <----------------- WAS

  ---------------------------------------------------------------

</pre>

We will now go over each step in detail.

<OL>

<LI> UA requests a webauth-protected resource from WAS.
     <p>
</LI>

<LI> mod_webauth detects the user doesn't have an app-token, and
   constructs a request-token for an id-token. The request-token 
   contains information
   such as the return URL, requested type of token, etc. The
   request-token is encrypted using an AES session key shared between the WAS
   and the WebKDC obtained from a webkdc-service-token.
   <p>mod_webauth then generates a redirect to the WebKDC 
     (including the request-token in the URL query parameters).
   <p>
</LI>

<LI> The redirect causes the user's browser (UA) to get sent to the WebKDC, along
   with the request-token. No cookies get sent to the WebKDC.
   <p>
</LI>

<LI> The WebKDC will then decrypt the request-token. 
     It will check the creation time to make sure the request is "fresh",
   and send back a login form to the UA. The request-token (or the
   information contained in it) will be placed in a hidden field.
   <p>
</LI>

<LI> The user enters their username/password and submits the form back
   to the WebKDC.
   <p>
</LI>
<LI>
   <p>The WebKDC validates the username/password, and also makes sure the
   that the WAS is allowed to request identity tokens.


   <p>Assuming the username/password is valid, the WebKDC will then construct
   a cookie for itself, which contains the proxy-token, and the id-token.

   <p>A confirmation page will be sent back to the browser, that when
     ok'd will do a GET on the original request, with the id-token
     appended to the original request.
   <p>
</LI>

<LI> The user's browser will now re-request the original resource, passing
     along the id-token in the URL.
     <p>
</LI>

<LI> mod_webauth will see the id-token in the request, and will
   check to make sure that it is fresh. It will then look at the subject
   authenticator-type in the token to see if it needs to verify
   the subject. If the authenticator-type is krb5, then it needs
   to use its keytab to verify the identity of the subject, which is
   the result of a krb5-mk-req API call.

   <p>After verifying the subject, mod_webauth will then rewrite the 
   id-token into an app-token, and create an app-token to be
   placed into a cookie for future requests.

   <p>mod_webauth will then strip off the token from the URL, and let
      the original app handle the request. Note that the tokens will
      not show up in the access_log.
   <p>
 </LI>
</OL>

<H3>2.2 <a name="sc2">Application Access, app-token</a></H3>

In the second scenario we discuss what happens when a user
requests a webauth-protected resource and already has an app-token.
This will be the most common case.

<p>

<pre>
  ---------------------------------------------------------------
      UA                 WAS            WebKDC
  ---------------------------------------------------------------

      request resource
  1.  -----------------> WAS

      response
  2.  <----------------- WAS

  ---------------------------------------------------------------

</pre>

We will now go over each step in detail.

<OL>

<LI> UA requests a webauth-protected resource from WAS.
     <p>
</LI>

<LI> mod_webauth detects the user has a valid app-token and grants access.
   <p>
</LI>
</OL>

<H3>2.3 <a name="sc3">Application Access, no app-token, proxy-token (Single Sign-on)</a></H3>

In the third scenario we discuss what happens when a user
requests a webauth-protected resource and doesn't have an app-token,
but has a proxy-token.

<p>This is the "Single Sign-on" case, because the WebKDC can use the
user's proxy-token to acquire access to the application without
having to prompt the user for their password again.
<p>


<pre>
  ---------------------------------------------------------------
      UA                 WAS            WebKDC
  ---------------------------------------------------------------

      request resource
  1.  -----------------> WAS

      redirect to WebKDC
  2.  <----------------- WAS

      request-token for id-token
  3.  -------------------------------> WebKDC

      redirect with returned token
  4.  <------------------------------- WebKDC

      re-request resource (with returned token in URL)
  5.  -----------------> WAS

      set the app-token cookie, response from app
  6.  <----------------- WAS

</pre>

We will now go over each step in detail.

<OL>

<LI> UA requests a webauth-protected resource from WAS.
     <p>
</LI>

<LI>
 mod_webauth detects the user doesn't have an app-token, and
   constructs a request-token for an id-token. The request-token 
   contains information
   such as the return URL, requested type of token, etc. The
   request-token is encrypted using an AES session key shared between the 
   WebKDC and the WAS obtained from a webkdc-service-token.
   <p>mod_webauth then generates a redirect to the WebKDC (including the request-token
  in the URL query parameters).
   <p>
</LI>

<LI> The redirect causes the user's browser (UA) to get sent to the WebKDC, along
   with the request-token.
   <p>
</LI>

<LI> The WebKDC detects the user has a valid proxy-token, and uses
   it to construct a new id-token. The WebKDC will then construct
   the return URL, which will contain the response-token, and
   the requested-token (in the response-token).
<p>
</LI>


<LI> The user's browser will now re-request the original resource, passing
     along the id-token in the URL.
     <p>
</LI>

<LI> mod_webauth will see the id-token in the request, and will
   check to make sure that it is fresh. It will then look at the subject
   authenticator-type in the token to see if it needs to verify
   the subject. If the authenticator-type is krb5, then it needs
   to use its keytab to verify the identity of the subject, which is
   the result of a krb5-mk-req API call.

   <p>After verifying the subject, mod_webauth will then rewrite the 
   id-token into an app-token, and create an app-token to be
   placed into a cookie for future requests.

   <p>mod_webauth will then strip off the token from the URL, and let
      the original app handle the request.
   <p>
 </LI>

<LI> The UA will save the app-token cookie, and then re-request the 
     original request.
   <p>
</LI>
<LI>
 The application will now serve the original request.
   <p>
</LI>
</OL>

<H3>2.4 <a name="sc4">Application Access, no app-token, credentials required (Proxied Credentials)</a></LI>
</H3>

In the fourth scenario we discuss what happens when a user
requests a webauth-protected resource and doesn't have an app-token,
and the application needs to use credentials.

<p>This is the "Proxy credentials" case. The WAS must request a proxy-token,
which it will then use to request additional credentials via the XML
interface. In this scenario we assume the WebKDC already has a proxy-token
for itself.
<p>


<pre>
  ---------------------------------------------------------------
      UA                 WAS                WebKDC
  ---------------------------------------------------------------

      request resource
  1.  -----------------> WAS

      redirect to WebKDC
  2.  <----------------- WAS

      request-token for proxy-token
  3.  ------------------------------------> WebKDC

      redirect with returned token
  4.  <------------------------------------ WebKDC


      re-request resource (with returned token in URL)
  5.  -----------------> WAS

                             request tokens 
  6.                     WAS -------------> WebKDC

                                 response
  7.                     WAS <------------- WebKDC

      set the cookies, response from app
  8.  <----------------- WAS

</pre>

We will now go over each step in detail.

<OL>

<LI> UA requests a webauth-protected resource from WAS.
     <p>
</LI>

<LI>
 mod_webauth (or mod_webauthproxy) detects the user doesn't have an 
   app-token containing the required credentials, and constructs a 
   request-token for a proxy-token. The request-token 
   contains information
   such as the return URL, requested type of token, etc. The
   request-token is encrypted using an AES session key shared between the 
   WebKDC and the WAS obtained from a webkdc-service-token.
   <p>mod_webauth then generates a redirect to the WebKDC (including the request-token
  in the URL query parameters).
   <p>
</LI>

<LI> The redirect causes the user's browser (UA) to get sent to the WebKDC, along
   with the request-token.
   <p>
</LI>

<LI> The WebKDC detects the user has a valid proxy-token, and uses
   it to construct a new proxy-token. The WebKDC will then construct
   the return URL, which will contain the proxy-token.
<p>
</LI>

<LI> The user's browser will now re-request the original resource, passing
     along the proxy-token.
     <p>
</LI>

<LI> mod_webauth will see the proxy-token in the request, 
   and check to make sure the request is fresh. It will then
   use the webkdc-proxy-token to make an XML request to the WebKDC for
   an id-token, and for whatever credential-tokens it
   needs.
   <p>

<LI> The WebKDC will receive the webkdc-proxy-token, and make sure
    the webkdc-service-token's subject is allowed to be use the 
    webkdc-proxy-token. If everything is ok, it
     will return the requested id and credential tokens. 
   <p>
<LI>
   <p>After verifying the id-token, mod_webauth will then rewrite the 
   id-token into an app-token, and also re-encrypt the credential token(s)
   using its private key. All the tokens will be placed
   into cookies for future requests. The proxy-token can be discarded.

   <p>mod_webauth will then strip off the token from the URL, and let
      the original app handle the request.
   <p>
<LI> The UA will save the cookies, and then re-request the 
     original request.
   <p>
</LI>
<LI>
   The application will now serve the original request.
   <p>The credentials will be passed to the application by having
    mod_webauth save the credentials into a ticket file, and setting an
    environment variable to point to that ticket file. When the credential
    file gets created will most likely be based upon an Apache
    directive. <b>Note:</b> this needs to be looked at in more detail,
    and other options may be needed.
<p>
</LI>
</OL>

<H3>2.5 <a name="logout">Logging Out</a></H3>

The easiest and most effective way to "logout" is to exit
the browser and/or logout of the operating system itself. All the
cookies that WebAuth uses are session cookies, meaning they
are only valid for the duration of a browser's particular execution.

<p>Aside from quitting the browser, there are two issues to consider when 
logging out:

<OL>
  <LI>Logging out of a single application
  <LI>Logging out of all applications
</OL>

<H4>2.4.1 Logging out of a single application</H3>

Logging out of an application involves having all the session cookies
associated with a given application on a given server removed.
This can be achieved by having a "logout" link available within
the application itself. Clicking on the URL can cause a logout page
to be displayed, that clears out all the cookies. It will be possible
to configure mod_webauth to do this automatically for certain
URLs (for example /mail/logout/), so the application doesn't
have to do it itself.

<p>mod_webauth can also be configured to send the user to a system-wide
logout page on the WebKDC. This would create a more consistent logout 
experience for users. The logout page could also remind the user that they may
be logged into other applications well, and could also have them click
on a link to destroy their proxy-token as well.

<p>It will also be possible for the application to specify a session
timeout, such that app-tokens will become invalid if they
aren't used within a certain period of time. This can also be combined
with an option that causes the application to request that the
proxy-token be ignored, effectively forcing the user to sign in again.


<H4>2.4.2 Logging out of all applications</H3>

As mentioned earlier, the easiest way to logout of all applications
would be to exit the browser. Aside from that, two things would
need to happen in order to "logout" from all applications:

<OL>
<LI>The user would need to go to the WebKDC's logout page so any proxy-tokens
    could get removed.</LI>
<LI>All applications would need to be configured to timeout inactive
sessions. That would force an application to make an id-token request,
and there would be no proxy-token.
</OL>
<p>
Note that its not possible for the WebKDC to remove individual app-token cookies,
since those cookies are scoped to each application server.

<p>

<H2><B>3. <a name="httpconv">WAS and WebKDC Conventions</a></B></H2>

<H3>3.1 Getting redirected to WebKDC</H3>

<p>Each WAS will be configured with a URL to redirect a UA to in the
event they need to make a request. When making the request, the WAS
must include both the request-token and the webkdc-service-token (so
the WebKDC can decrypt the request-token).
<p> These tokens will be passed via query parameters in the URL.
The format is:

<pre>
  https://{webkdc-host}/{webkdc-login-uri}?RT=request-token;ST=service-token
</pre>

<p>Where <b>RT</b> is the base64-encoded request-token and <b>ST</b> is
the base64-encoded service-token.

<H3>3.2 Getting redirected back to WebAuth App Server</H3>

<p>When the WebKDC is ready to redirect the UA back to the WAS,
it will construct a return URL by taking the return-url specified
in the request token an appending ";WEBAUTHR=token;" to it, where
token is the requested token. If the "as" attribute was specified
in the request token, then it is base64-encoded and appended to
the URL as ";WEBAUTHS=token;".

<p>For example:

<pre>
  https://{return-url};WEBAUTHR=token;[;WEBAUTHS=token;]
</pre>

<p>The WebAuth Apache module will then strip ";WEBAUTHS=token;"
and ";WEBAUTHR=token;" off the end of the URL. If the tokens are
valid, the WebAuth module will construct the app-token cookie, 
etc, then do another redirect back to the URL with the extra information
stripped off.

<H2><B>4. <a name="xmlproto">WebKDC XML Protocol Description</a></B></H2>

This section describes the XML protocol used to talk to the WebKDC. 

<H3>4.1 <a name="xmlover">Protocol Overview</a></H3>

<p>	The protocol consists of an exchange of XML-formatted 
messages over a tcp-based connection. A protocol interaction 
consists of a single XML message from the client and a single XML 
message response from the server.
<p> For any elements that require a base64-encoded value, there must
    be no whitespace after the open element and before the close element.
    For example, this is valid:
<pre><code> &lt;requestToken>{base64-webkdc-service-token}&lt;/requestToken></code></pre>
while this is not:
<pre><code> &lt;requestToken>
            {base64-webkdc-service-token}
 &lt;/requestToken></code></pre>
<p>Having said that, this spec uses whitespace in examples for readability.

<p> The message is posted to the WebKDC using HTTPS.

<p>
The command request format is:
<pre><code>
  &lt;xxxxRequest>
    &lt;messageId>{message-id}&lt;/messageId>   &lt;!-- optional, no default -->
    &lt;protocolVersion>1&lt;/protocolVersion>  &lt;!-- optional, default is 1 -->
    &lt;!-- rest depends on command -->
  &lt;/xxxxRequest>
</code></pre>

The command response format on success is:
<pre><code>
  &lt;xxxxResponse>
    &lt;messageId>{message-id}&lt;/messageId>   &lt;!-- only if present in request -->
    &lt;!-- rest depends on command -->
  &lt;/xxxxResponse>

</code></pre>

The command response format on failure is:
<pre><code>
  &lt;errorResponse>
    &lt;messageId>{message-id}&lt;/messageId>   &lt;!-- only if present in request -->
    &lt;errorCode>{numeric}&lt;errorCode>
    &lt;errorString>{message}&lt;errorString>
  &lt;/errorResponse>

</code></pre>


<H3>4.2 <a name="xmlcom">Common Elements</a></H3>
The following elements are common cross all commands.
<H4>4.2.1 &lt;messageId></H4>
If a request message contains a &lt;messageId> element, then the value
used within this element <b>MUST</b> be returned in the response message
corresponding to the request.

<H4>4.2.2 &lt;protocolVersion></H4>
This is an optional string that specifies the version of the protocol
in use. The default value if not specified is 1. Currently, the only
supported protocol is version 1, using any other value <b>MUST</b> return
an error.

<H4>4.2.3 &lt;errorCode></H4>
This is a numeric error code that is present in an errorResponse message.
<p>
<table border>
 <tr align=center>
  <th>Error Code</th>
  <th>Description</th>
 </tr>

<tr>
  <td>1</td> <td> The service-token used was expired. </td>
</tr>

<tr>
  <td>2</td> <td> The service-token used was corrupt and/or was unable to 
                  be decrypted. 
  </td>
</tr>

<tr>
  <td>3</td> <td> The proxy-token used was expired. 
  </td>
</tr>
<tr>
  <td>4</td> <td> The proxy-token used was corrupt and/or was unable to 
                  be decrypted. 
  </td>
</tr>

<tr>
  <td>5</td> <td> The request was invalid. For example, a required element
                  was missing, an attribute value was incorrect, the server
                  was unable to parse the XML request, etc. The generally
                  indicates a bug in the client.
  </td>
</tr>

<tr>
 <td>6</td> <td> The request was unauthorized. An attempt was made to
                  request a token type that was not authorized.
 </td>
</tr>

<tr>
 <td>7</td> <td> The server had an internal error (out of memory, etc). 
                 If the client retries the request may succeed, though
                 some external event might be causing the problem (Kerberos
                 server being down, etc).
 </td>
</tr>

<tr>
 <td>8</td> <td> The request-token was stale.
 </td>
</tr>

<tr>
 <td>9</td> <td> The request-token was invalid.
 </td>
</tr>

<tr>
 <td>10</td> <td>Unable to obtain the requested credential.
 </td>
</tr>

<tr>
 <td>11</td> <td>The krb5 &lt;requesterCredential> was bad.
 </td>
</tr>

<tr>
 <td>12</td> <td>The login-token was stale.
 </td>
</tr>

<tr>
 <td>13</td> <td>The login-token was invalid.
 </td>
</tr>

<tr>
 <td>14</td> <td>Login failed due to bad password or invalid username.
 </td>
</tr>

<tr>
 <td>15</td> <td>A webkdc-proxy-token of a certain type was 
             required and was not present in the request.
 </td>
</tr>

</table>

<H4>4.2.4 &lt;errorMessage></H4>
This is a textual description of the error code, meant to be human readable, 
but not actually displayed to the user (it is not localized). 

<H3>4.3 <a name="xmlcmd">Commands</a></H3>
There are currently two commands defined, getTokens and requestToken.
The getTokens command is used directly by the WAS to request a service token,
cred-tokens, etc. The requestToken command is used by the web front-end
on the WebKDC itself to process a request-token sent in a URL from a
WAS.

<H4>4.3.1 <a name="xmlgettokens">getTokens</a></H4>

The getTokens command is used to request tokens (service, id, proxy).
The subject's credentials are the username/password of the user,
or a proxy-token obtained on behalf of the user.

<p>
The request message is:
<pre><code>
  &lt;getTokensRequest>

    &lt;requesterCredential type="service|krb5">
       <i>&lt;!-- for type="service" --></i>
       {base64-webkdc-service-token}
       <i>&lt;!-- for type="krb5" --></i>
       {base64-krb5-mk-req-data}
    &lt;/requesterCredential>

    &lt;subjectCredential type="proxy">
       &lt;proxyToken>{base64-webkdc-proxy-token}&lt;/proxyToken>
       <i>&lt;!-- additional &lt;proxyToken>...&lt;/proxyToken> here --></i>
    &lt;/subjectCredential>

    <i>&lt;!-- present when requestCredential is of type="service" --></i>
    &lt;requestToken>{base64-request-token}&lt;/requestToken>

    &lt;tokens>
      &lt;token type="id|proxy|service|cred" id="{id-to-use-in-response}">
        <i>&lt;!-- for type="id" --></i>
         &lt;authenticator type="krb5|webkdc"/> <i>&lt;!-- optional, default is krb5 --></i>
        <i>&lt;!-- for type="proxy" --></i>
         &lt;proxyType>krb5|krb4&lt;/proxyType>
        <i>&lt;!-- for type="cred" --></i>
         &lt;credentialType>krb5|krb4&lt;/credentialType>
         &lt;serverPrincipal>{krb4/krb5-service}&lt;/serverPrincipal>
      &lt;/token>
      <i>&lt;!-- additional &lt;token>...&lt;/token> requests go here --></i>
    &lt;/tokens>
  &lt;/getTokensRequest>
</code></pre>

The response message is:

<pre><code>
  &lt;getTokensResponse>
    &lt;tokens>
      &lt;token id="{id-from-request}">
        &lt;tokenData>{base64}&lt;/tokenData>
        <i>&lt;!-- for type="service" --></i>
        &lt;sessionKey>{base64-session-key}&lt;/sessionKey>
        &lt;expires>{expiration-time}&lt;/expires>
      &lt;/token>
      <i>&lt;!-- additional &lt;token>...&lt;/token> responses go here --></i>
    &lt;/tokens>
  &lt;/getTokensResponse>
</code></pre>

<p>If any errors occur, then an &lt;errorResponse> message will be returned.

<p>requesterCredentials of type "krb5" can only be used to obtain
a service-token, they can't be used for obtaining any other tokens,
nor can a credential of type "service" be used to request another
service-token.

<p>subjectCredentials are required when requesting id, proxy, or cred
tokens.

<H4>4.3.2 <a name="xmlrequesttoken">requestToken</a></H4>

The requestToken command is used by the web front-end running on the
WebKDC to process a request-token sent in a URL from a WAS.
<p>
The request message is:
<pre><code>
  &lt;requestTokenRequest>

   &lt;requesterCredential type="service">
       {base64-webkdc-service-token}
   &lt;/requesterCredential>

   &lt;subjectCredential type="proxy|login">
     <i>&lt;!-- for type="proxy" --></i>
     <i>&lt;!-- need to pass in all the existing proxy-tokens, since
          we (the web front-end) don't know which we might need --></i>
     &lt;proxyToken>...&lt;/proxyToken>
     <i>&lt;!-- additional &lt;proxyToken>...&lt;/proxyToken> here --></i>
     <i>&lt;!-- for type="login" --></i>
     &lt;loginToken>...&lt;/loginToken>     
   &lt;/subjectCredential>

   <i>&lt;!-- request token from WAS --></i>
   &lt;requestToken>{base64-request-token}&lt;/requestToken> 

  &lt;/requestTokenRequest>
</code></pre>
The response message is:
<pre><code>
  &lt;requestTokenResponse>
    <i>&lt;!-- any updated/new proxy tokens created, only passed back
         if subjectCredential was type="login"  --></i>
    &lt;proxyTokens>
      &lt;proxyToken type="...">{base64-proxy-token}&lt;/proxyToken>
    &lt;/proxyTokens>

    <i>&lt;!-- the url to return to the user to --></i>
    &lt;returnUrl>...&lt;/returnUrl>

    <i>&lt;!-- subject inside of service-token used to make request --></i>
    &lt;requesterSubject>...&lt;/requesterSubject>

    <i>&lt;!-- requestedToken will either be an error, id, or proxy token. --></i>
    &lt;requestedToken>{base64-token}&lt;/requestedToken>

    <i>&lt;!-- app state is the opaque app state passed in the
         request token that we hand back to WAS --></i>
    &lt;appState>{base64-state}&lt;/appState>

  &lt;/requestTokenResponse>
</code></pre>

<p>If any errors occur, then an &lt;errorResponse> message will be returned.

<H3>4.4 <a name="xmlpost">Posting XML to WebKDC</a></H3>

The WebKDC will be an apache 2.0 module. The XML data should be POSTed to
the following URL:

<pre><code>https://{webkdc-server}/webkdc-service/</code></pre>

<p>The <code>Content-Type</code> should be "text/xml".

<p>Initially only SSL will be supported. If performance becomes a 
concern, a non-ssl port may be opened up, in which case the
content will need to be encrypted, most likely using AES.

<H3>4.5 <a name="xmlex">Examples</a></H3>

<H3>4.5.1 WAS asking for a webkdc-service-token</H4>

In this example, the WAS requests a webkdc-service-token for itself. This 
happens when the WAS needs to acquire a webkdc-service-token to talk to the WebKDC. It
will cache the token until it nears expiration time, at which
point it will request a new one.

<pre><code>
&lt;getTokensRequest>
   &lt;requesterCredential type="krb5">
      {base64-krb5-mk-req-data}
   &lt;/requesterCredential>
   &lt;tokens>
     &lt;token type="service" id="0"/>
   &lt;/tokens>
&lt;/getTokensRequest>

&lt;getTokensResponse>
  &lt;tokens>
    &lt;token id="0">
      &lt;sessionKey>{base64-session-key}&lt;/sessionKey>
      &lt;expires>{expiration-time}&lt;/expires>
      &lt;tokenData>{base64}&lt;/tokenData>
    &lt;/token>
  &lt;/tokens>
&lt;/getTokensResponse>
</code></pre>

<H3>4.5.2 WAS asking for a credential-token</H4>

In this example, the WAS requests an K5 ticket using its webkdc-proxy-token.
The webkdc-proxy-token's type must match the requested credential's type.

<pre><code>
 &lt;getTokensRequest>
   &lt;requesterCredential type="service">
       {base64-webkdc-service-token}
   &lt;/requesterCredential>

   &lt;requestToken>{base64-request-token}&lt;/requestToken>

   &lt;subjectCredential type="proxy">
     {webkdc-proxy-token}
   &lt;/subjectCredential>
  &lt;tokens>
    &lt;token type="credential" id="0"/>
      &lt;credentialType>krb5&lt;/credentialType>
      &lt;serverPrincipal>service/ldap@stanford.edu&lt;/serverPrincipal>
    &lt;/token>
  &lt;/tokens>
&lt;/getTokensRequest>

&lt;getTokensResponse>
  &lt;tokens>
    &lt;token id="0">
      &lt;tokenData>{base64}&lt;/tokenData>
    &lt;/token>
  &lt;/tokens>
&lt;/getTokensResponse>
</code></pre>

<p>The WebKDC will verify that the webkdc-proxy-token was granted to the
same server specified inside of the webkdc-service-token.

<H2><B>5. <a name="tokenformat">Tokens</a></B></H2>

<H3>5.1 <a name="tokenencoding">Token Encoding</a></H3>

<p>All encrypted-tokens have the following general encoding:

<pre>{key-hint}{nonce}{hmac}{token-attributes}{padding}</pre>

<p>Everything except {key-hint} is AES-encrypted.

<p><code>key-hint</code> is UNIX UTC time stored in network byte order, and 
is four bytes long. It does not get encrypted, and is only used as a *hint* 
for the server
to determine which key to use to decrypt the token. It should not be used
for any other purpose as its value is not protected from modification.

<p><code>nonce</code> is 16 random bytes, and gets encrypted with the rest of the data
in the token. It is used to ensure that two tokens with the same data
and same encryption key don't encrypt to the same value.

<p><code>hmac</code> is the sha1 hmac of the actual data (name/value pairs),
including the padding. The key used with HMAC is the AES private-key.
Note, a better solution would be to use a different key, but that requires
have two keys or using a key-derivation function to derive the HMAC
key from the AES key. One approach would be to use a key-derivation function
like TLS uses.

<p><code>token-attributes</code> consists of a sequence of name=value pairs,
separated by a ';' character. names are not allowed to contain 
an "=" or a ";", and values <b>MAY</b> contain binary data, but <b>MUST</b> 
escape any ";"'s in the data with an extra ";".

<p>For example, if we had the following names and values:

<pre>
  a=1
  msg=hello;there
  bin={binarydata}
  b=2
</pre>
<p>They would get encoded as:

<pre>
  a=1;msg=hello;;there;bin={binarydata};b=2;
</pre>

<p>padding is any additional padding of the data to make the length
a multiple of 16 bytes for AES encryption. Note, there is always 
padding present. If the length is already a multiple of 16, then 
16 bytes of padding will be added. The value of each padding
byte will be equal to the length of the padding. For example, if
the padding length is 7, then each byte will be equal to 0x07.

<p>Tokens get base64 encoded before being used as a cookie, 
query parameter, or within XML data.

<H3>5.2 <a name="tokenattrs">Assigned Token Attributes</a></H3>

<p>The following is the list of assigned token attributes. All
attributes used within tokens are listed in this table.

<p>All time values are stored in network byte order, and are the number of
seconds since 00:00:00 UTC, January 1, 1970.

<table border>
 <tr align=center>
  <th>Name</th>
  <th>Encoding</th>
  <th>Description</th>
 </tr>
<tr>
  <td>as</td><td>binary</td>
  <td>The app-token that is optionally included within a request-token that
      will get returned along with the response to the request-token.</td>
</tr>
<tr>
  <td>cmd</td><td>string</td>
  <td>name of XML command being executed (i.e., getTokensRequest)</td>
</tr>
<tr>
 <td>crd</td> <td>binary</td>
<td>credential data (i.e., an encoded krb5 service ticket)</td> 
</tr>
<tr>
 <td>crt</td><td>string</td><td>credential type (krb4, krb5)</td>
</tr>
<tr>
 <td>ct</td><td>binary time</td><td>creation time of the token. For tokens used
to exchange messages between servers (request, error, id, proxy, credential) ,
this value is used to ensure that the request is "fresh". For example,
tokens of this type with a <b>ct</b> older then 5 minutes will get
flagged by the server (WAS or WebKDC) as being "stale". </td>
</tr>
<tr>
 <td>ec</td> <td>string</td><td>error code from WebKDC. FIXME: need to
document the valid error codes, they will be the same as the error codes
returned in XML messages.</td>
</tr>
<tr>
 <td>em</td><td>string</td><td> error message from WebKDC. Should only be used for logging and/or debugging, since it not localized or in a format meant for end-user consumption.</td>
</tr>
<tr>
 <td>et</td><td>binary time</td><td>expiration time of the token</td>
</tr>
<tr>
 <td>it</td> <td>string</td><td>inactivity timeout in seconds. If this attribute is set in an app-token, then when the token is used the current time minus
the <b>it</b> value is compared against the  <b>lt</b> </td> attribute to
see if the token has timed out due to inactivity.
</tr>
<tr>
 <td>k</td><td>binary</td><td>AES session key.</td>
</tr>
<tr>
 <td>lt</td><td>binary time</td><td>last-used time. If this attribute is set in
an app-token, then it will be periodically updated as the token is used.</td>
</tr>
<tr>
 <td>p</td><td>string</td><td>user's password</td>
</tr>
<tr>
<tr>
 <td>pd</td><td>binary</td><td>proxy data (i.e., an encoded krb5 tgt)</td>
</tr>
<tr>
 <td>ps</td> <td>string</td><td>proxy subject, the subject from the
service-token used when the proxy-token was granted.
</tr>
<tr>
 <td>pt</td><td>string</td><td>proxy type (krb4/krb5)</td>
</tr>
<tr>
 <td>rr</td><td>string</td>
<td>reason for request:
       na = no app-token,
       ea = expired app-token,
       st = session timeout,
       fa = forced authentication (app is requesting "live" authentication)
</td>
</tr>
<tr>
 <td>rtt</td><td>string</td><td>requested token type: id = id-token, 
proxy = proxy-token</td>
</tr>
<tr>
 <td>ru</td><td>string</td><td>return URL. The url to return the user to after authenticating with the WebKDC</td>
</tr>
<tr>
 <td>s</td><td>string</td><td>authenticated subject. In service-tokens
this is the server that authenticated to get the service-token, in all
other tokens it is the user that authenticated. Server subjects have the form
"type:identifier". Currently, the only defined type is "krb5", and the
identifier is the krb5 principal (i.e., krb5:host/lichen.stanford.edu@stanford.edu).
</td>
</tr>
<tr>
 <td>sa</td><td>string</td><td>subject authenticator type (krb5, webkdc)</td>
</tr>
<tr>
 <td>sad</td><td>binary</td><td>subject authenticator data. For sa of type krb5 this is a krb5_mk_req using the same krb5 principal as the service-token's subject</td>
</tr>
<tr>
 <td>t</td><td>string</td><td>token type: webkdc-service, webkdc-proxy, req, error, id, proxy, cred, app. Used by a server to ensure that a token is
being used for the correct purpose. </td>
</tr>
<tr>
 <td>wt</td> <td>binary</td><td>webkdc-{proxy,service}-token (the webkdc tokens inside another token)</td>
</tr>
<tr>
 <td>u</td><td>string</td><td>user's username</td>
</tr>
<tr>
</table>

<H3>5.3 <a name="tokenspecific">Specific Token Encodings</a></H3>

<p>The following sections describe which attributes are include with
which tokens.

<H4>5.3.1 <a name="tokenwebkdcservice">webkdc-service-token encoding</a></H4>

<p>webkdc-service-tokens are used by WAS servers to communicate with
the WebKDC. They get returned from WebKDC after an entity authenticates
with the WebKDC using the XML-interface while requesting a service-token.

<pre><code>
  t=webkdc-service
  k={session-key}
  s=krb5:{requesting-servers-k5-principal}
  ct={creation-time}
  et={expiration-time}
</code></pre>

<p>  All attributes are AES-encrypted in WebKDC's private key. 
  The server that initially requested the token would also have
  received {session-key} and {expiration-time} out-of-band from
  the token itself and stored them for the duration of the token.

<H4>5.3.2 <a name="tokenwebkdcproxy">webkdc-proxy-token encoding</a></H4>

A webkdc-proxy-token is a k4/k5 TGT maintained by the WebKDC on behalf
of another user, or on behalf of itself.

<pre><code>
  t=webkdc-proxy
  ps={subject-from-webkdc-service-token-used-to-get-proxy-ticket}
  pt=krb5|krb4|...
  s={username}
  pd={proxy-data}
  ct={creation-date}
  et={expiration-date}
</code></pre>

<p> All attributes are AES-encrypted in the WebKDC's private key.

<p> When a webkdc-proxy-token is used, the WebKDC checks that
the subject in the service-token making the request is authorized
to used the webkdc-proxy-token granted to the <b>ps</b> subject.

<H4>5.3.3 <a name="tokenrequest">request-token encoding</a></H4>

A request-token gets sent to the WebKDC server by WAS, along with the WAS's
webkdc-service-token. They are used to request tokens via the HTML interface,
and are also used with the XML interface (in a restricted form) to allow
the WebKDC to verify that a request being made with a service-token is
both recent, and for the specified command.

<p> The first form is used with the requestTokenRequest command:

<pre><code>
  t=req
  ct={creation-time}
  [as={binary-app-token-used-for-state}]
  ru={return-get-redirect-url}
  rr=na|ea|st|fa
  rtt=id|proxy
  # for rt=id
  sa=krb5|webkdc
  # for rt=proxy
  pt=krb5|krb4
</code></pre>

<p> The second form is used with the getTokensRequest command:

<pre><code>
  t=req
  ct={creation-time}
  cmd={xml-command-we-are-going-to-execute}
</code></pre>

<p>All attributes are AES-encrypted in the webkdc-service-token session-key.

<p>  The value of <code>ct</code> is used to prevent replay attacks. Values older then 
  a certain time (probably 5 minutes by default) should be rejected as
  a replay.

<p>  <code>cmd</code> indicates which XML command we are invoking
   (i.e., getTokensRequest). The WebKDC will compare this command
   against the name of the command in the XML.

<H4>5.3.4 <a name="tokenerror">error-token encoding</a></H4>

An error-token gets sent from the WebKDC as a response to a request-token
when an error has occurred.

<pre><code>
  t=error
  ct={creation-time}
  ec={error-code}]
  em={error-message}]
</code></pre>

<p>  All attributes are AES-encrypted in the webkdc-service-token session-key

<p>  The value of <code>ct</code> is used to prevent replay attacks. Values older then 
  a certain time (probably 5 minutes by default) should be rejected as
  a replay.

<H4>5.3.5 <a name="tokenid">id-token encoding</a></H4>

The id-token gets returned from WebKDC, and is bound to an WAS. They
are used to express the identity of user. 

<pre><code>
  t=id
  sa=krb5|webkdc
  # for sa=webkdc
  s={username}
  # for sa=krb5
  sad={result-of-krb5-mk-req-for-webauth/hostname}
  ct={creation-time}
  et={expiration-time}
</code></pre>

<p>All attributes are AES-encrypted in the webkdc-service-token session-key

<p>If "at" is krb5, then "s" (subject) is the result of a call
  to krb5_mk_req for the webauth/WAS service using the user's tgt.

<p>If "at" is webkdc, then we are trusting the webkdc and "s" already contains
  the users's principal name.

<p>The value of "ct" is used to prevent replay attacks. Values older then 
  a certain time (probably 5 minutes by default) should be rejected as
  a replay, as id-tokens are only used once and re-written into an app-token.

<p>The value of "et" is used to let the application know how long the
   subject of the id-token should be considered valid for. The
   value for "et" is the expiration time of the proxy-token used to create
   it.

<H4>5.3.6 <a name="tokenproxy">proxy-token encoding</a></H4>

An proxy-token gets returned when a WAS requests a proxy-token
from the WebKDC.

<pre><code>
  t=proxy
  pt=krb5|krb4|...
  s={username}
  wt={webkdc-proxy-token}
  ct={creation-time}
  et={expiration-time}
</code></pre>

<p>All attributes are AES-encrypted in the webkdc-service-token session-key

<p>The value of "ct" is used to prevent replay attacks. Values older then 
  a certain time (probably 5 minutes by default) should be rejected as
  a replay, as proxy-tokens are only used once and re-written into an 
  app-token.

<p> <code>wt</code> is the webkdc-proxy-token (in binary form) that 
was returned as the result of the request.

<H4>5.3.7 <a name="tokencred">credential-token encoding</a></H4>

A credential-token is k4/k5 service ticket returned by the WebKDC for a WAS.

<pre><code>
  t=cred
  ct=krb5|krb4|...
  s={username}
  cd={credential-data}
  ct={creation-date}
  et={expiration-date}
</code></pre>

<p> All attributes are AES-encrypted in the in a webkdc-service-token session-key

<H4>5.3.8 <a name="tokenlogin">login-token encoding</a></H4>

A login-token is created by the web front-end running on the WebKDC
when it needs to authenticate a user. 

<pre><code>
  t=login
  ct={creation-time}
  p={password}
  u={username}
</code></pre>

<p>  All attributes are AES-encrypted in the WebKDC's private key.

<H4>5.3.9 <a name="tokenapp">app-token encoding</a></H4>

An app-token is controlled/maintained by a WAS. The main use of an app-token
is to cache the idenity within an id-token after it has been verified.

<pre><code>
  t=app
  et={expiration-time}
  [ct={creation-time}]
  [s={username}]
  [k=session-key]
  [it={inactivity-timeout}]
  [lt={last-use-time}]
</code></pre>

<p>  All attributes are AES-encrypted in the WAS's private key.

<p>  app-tokens are created by mod_webauth on first receipt of an id-token.
  After the id-token is verified, it gets converted into an app-token.

<p>  last-use-time is only included if session timeouts are turned on.
  The app-token would periodically get updated as it was used.

<p>  inactivity-timeout is used to compare the last-use-time against the
  current time to see if an app-token has become inactive due to not being
  used.

<p> session-key is only present when an app-token is being used
as the application-state inside of a request-token.

<H2><B>6. <a name="cookies">Cookie conventions</a></B></H2>

Cookies are used to hold tokens for future use by a UA. All cookies
are scoped to a single server, there are no domain-wide cookies. All
cookies will be encoded in base64 before passing them to the UA.

<p>The tokens that get used in cookies are webkdc-proxy-tokens,
proxy-tokens, app-tokens, and cred-tokens. The following naming convention
will be used to name cookies.

<p><b>NOTE:</b> proxy-tokens and cred-tokens get decrypted using
a session key, but will get re-encrypted using the WAS private
key before getting stored in a cookie.

<p>app-token cookies will have the name:

<pre>  <code>webauth_at</code></pre>

<p>webkdc-proxy-token cookies have the following naming convention:

<pre>  <code>webauth_wpt_{proxy-type}</code></pre>

<p>Where proxy-type is krb4 or krb5 depending on the type of the proxy-token.

<p>proxy-tokens will have following naming convention:

<pre>  <code>webauth_pt_{proxy-type}</code></pre>

<p>Where proxy-type is krb4 or krb5 depending on the type of the proxy-token.

<p>cred-tokens will have the following naming convention:

<pre>  <code>webauth_ct_{cred-type}_{service-name}</code></pre>

<p>where cred-type is krb4 or krb5 depending on the type of the cred-token.
service-name will be the krb4 or krb5 service name, potentially with
special characters escaped. <b>XXX:</b> need to compare valid characters in
a krb4 and krb5 service name against valid characters in a cookie name.

<pre>

<H2><B>7. <a name="apache">Apache Directives</a></B></H2>

apache directives:

AuthType WebAuth|StanfordAuth?
WebAuthAuthenticator krb5|webkdc
WebAuthInactiveExpire {seconds}
WebAuthHardExpire {seconds}
WebAuthCauseReAuth on|off
WebAuthEndSession redirect|clearLogin|on|off

</pre>
<hr>
<h4>Revision History:</h4>

<table border>
 <tr align=center>
  <th>Date</th>
  <th>Version</th>
  <th>Author</th>
  <th>Changes</th>
 </tr>
<tr>
  <td>10/02/2002</td>
  <td>0.1</td>
  <td>schemers</td>
  <td><ul><li>first draft</ul></td>
</tr>
<tr>
  <td>10/04/2002</td>
  <td>0.2</td>
  <td>schemers</td>
   <td><ul>
         <li>fixed typos, added more text in section 1.2
         <li>Use SHA1 everywhere instead of MD5
         <li>Change attribute separator in tokens from "\n" to ";"
         <li>Change time attributes inside of
            tokens from 4 byte binary network byte order to ASCII strings.
         <li>Changed description of time prepended to tokens from
	    <code>creation-time</code> to <code>key-hint</code>
       </ul>
   </td>
</tr>
<tr>
  <td>10/07/2002</td>
  <td>0.3</td>
  <td>schemers</td>
   <td><ul>
         <li>Major changes, combine LS and WKDC into WebKDC
       </ul>
   </td>
</tr>

<tr>
  <td>10/26/2002</td>
  <td>0.4</td>
  <td>schemers</td>
   <td><ul>
         <li>Change time attributes inside of tokens back to 
             4 byte binary network byte order.
         <li>get rid of default values for attributes

         <li>requested token is now contained within the response-token
         <li>got rid of unneeded/not-fleshed-out token attributes 
             (rth, san, ver)
         <li>add new token attributes (rt, rt-t, rt-et, sad)
         <li>change id-token to use "sad" instead of "s" for krb5
       </ul>
   </td>
</tr>

<tr>
  <td>10/30/2002</td>
  <td>0.5</td>
  <td>schemers</td>
   <td><ul>
         <li>use errorResponse message for indicating errors
         <li>remove app names for now, will re-specify when
             requirements are more clear
         <li>change "et" in id-token to "se", to indicate when
            the subject expires.
       </ul>
   </td>
</tr>

<tr>
  <td>11/01/2002</td>
  <td>0.6</td>
  <td>schemers</td>
   <td><ul>
         <li>rename service-token and proxy-token to webkdc-service-token
             and webkdc-proxy-token, to signify they are only used
             by the webkdc
         <li> remove response-token, add error-token and new proxy-token.
              The response from a request-token is either an
              error-token, id-token, or proxy-token
         <li>change "se" back to "et". Expiration times in tokens
             indicate when the token expires and when any data within
             the token (subject info, proxy data, etc) expires
         <li>simplify XML messages by placing base64-encoded data
             directly in &lt;requestCredential> and &lt;subjectCredential>
             instead of having them in another tag
         <li>wrap tokens in &lt;tokens> element to make it easier
             to iterate through all the tokens in a &lt;getTokensRequest>
       </ul>
   </td>
</tr>

<tr>
  <td>11/03/2002</td>
  <td>0.61</td>
  <td>schemers</td>
   <td><ul>
         <li>add new form of request-token that gets sent in XML requests
             along with a service-token to indicate which XML command
             is being requested.
         <li> update &lt;requesterCredential&gt; for type "service" to
              include &lt;serviceToken&gt; and &lt;requestToken&gt;.
       </ul>
   </td>
</tr>

<tr>
  <td>11/05/2002</td>
  <td>0.7</td>
  <td>schemers</td>
   <td><ul>
         <li>rename prt/prd/pro attributes to pt/pd/ps
         <li>formatting and clarification
       </ul>
   </td>
</tr>

<tr>
  <td>11/07/2002</td>
  <td>0.8</td>
  <td>schemers</td>
   <td><ul>
         <li>add section on security model and support for 
             sending application-state in a request token to 
	     enable server pools.
       </ul>
   </td>
</tr>

<tr>
  <td>11/08/2002</td>
  <td>0.85</td>
  <td>schemers</td>
   <td><ul>
         <li>Forgot to final webauth redirect in the usage scenarios that
             sets the cookies and re-requests original URL.
       </ul>
   </td>
</tr>
<tr>
  <td>11/13/2002</td>
  <td>0.90</td>
  <td>schemers</td>
   <td><ul>
         <li>undo 0.85, since after initial Apache prototyping I think
             we can get away without doing the extra redirect.
	 <li>add some text to "Security Model" section describing what
             happens if a user bookmarks or replays a url with a token in it.
       </ul>
   </td>
</tr>
<tr>
  <td>11/14/2002</td>
  <td>0.91</td>
  <td>schemers</td>
   <td><ul>
         <li>don't rewrite proxy/cred-tokens into app-tokens before
             storing them in cookies, just re-encrypt them using
             the WAS private key. This is so they can't be used
             as app-tokens.
         <li>change name of proxy/webkdc-proxy cookies
       </ul>
   </td>
</tr>

<tr>
  <td>11/27/2002</td>
  <td>0.92</td>
  <td>schemers</td>
   <td><ul>
         <li>document error codes for &lt;errorCode>
         <li>add new requestToken command for the WebKDC web front-end
             to use to talk to the WebKDC.
         <li>url for webkdc post is now /webkdc-service/
         <li>remove line that says an &lt;errorCode> can occur within
            a &lt;token> returned in a  &lt;getTokensResponse>. The whole
            request succeeds or fails.
         <li>update format for &lt;SubjectCredential> to be consistent
             across XML commands.
         <li>update format for &lt;requesterCredential> by moving
             &lt;requestToken> out into enclosing element, which also
             removes the need for the &lt;serviceToken> element. Also
             consistent across commands.
         <li>only subject names in service-tokens have the form 
             "krb5:{principal}", subject names referring to users
             will have only the username (unless krb5 is used and
	     the call to krb5_aname_to_localname fails, in which case
             the fully-qualified principal name will be used).
       </ul>
   </td>
</tr>

</table>

</body>
</html>