                            Weblogin Page Flow

Introduction

  Weblogin is the name for the component of WebAuth that handles user
  authentication interaction.  It is a CGI service that runs on the WebKDC
  and presents HTML login forms, status pages, and handles translating
  browser cookies into XML requests to the WebKDC and vice versa.

  We want to support SPNEGO as a possible authentication mechanism for
  users.  However, attempting SPNEGO unconditionally has deleterious
  effects in some browsers:  some versions of Opera hang or stop loading
  the page with an error, and IE throws up a basic-auth dialog box unless
  the Weblogin URL has been added to its intranet sites.  We therefore
  want to permit a configuration where the username/password dialog box is
  always shown first, but the user may choose to attempt SPNEGO, and then
  may also choose to set a cookie that always directs them to SPNEGO.

Basic Page Flow

  Here is the Weblogin page flow in the basic case where no SPNEGO
  complications are introduced:

   1. User is sent to Weblogin with a request token and a webkdc-service
      token from the WAS.  Weblogin passes that request and any single
      sign-on cookies from the browser to the WebKDC.  If the WebKDC says
      that authentication is successful (based on the cookies, generally,
      but it is also allowed to make out-of-band decisions even though it
      generally won't), it returns an id token or proxy token and says it
      was successful.  In that case, go to step 3.  Otherwise, proceed to
      step 2.

   2. Weblogin presents a username/password form, keeping the request
      token in a hidden field.  This form will also have an "I don't want
      to log in" link if the application provided a cancel URL.  If the
      user submits a username and password, it is validated with the
      WebKDC.  If that validation fails, they are returned to the same
      page with an error.  If it succeeds, they proceed to step 3.

   3. User is presented with a confirmation page that states their
      authenticated identity, provides a link back to the original service
      with the id or proxy token in the URL, and also provides an "I don't
      want to log in" link going to the cancel URL of the application if
      provided by the initial request.

Page Flow with SPNEGO

  If we always try SPNEGO first, using the configuration in install-spengo
  that sets up an alias to the login script as an authentication failure
  handler, we get the following page flow:

   1. User is sent to Weblogin with a request token and a webkdc-service
      token from the WAS.  Weblogin (via Apache) attempts an SPNEGO
      challenge.  If they succeed, Weblogin is called with REMOTE_USER
      set.  It uses that information to generate an artificial single
      sign-on token and calls the WebKDC with it to get an appropriate id
      or proxy token.  If that authentication is sufficient, go to step 5.
      Otherwise, go to step 2.

      If SPNEGO does *not* succeed, Apache throws an authentication error
      (401) and then dispatches the request to the 401 error handler.  Go
      to step 3.

   2. SPNEGO succeeded, but that wasn't sufficient to authenticate the
      user.  Present the regular username/password dialog with hidden
      fields as above, repeat until the username/password works, and then
      go to step 5.

   3. The login page is invoked again as a 401 error handler and reads the
      request token and webkdc-service token out of the separate
      environment variables Apache uses for error handlers.  This login
      page must obviously not be protected by SPNEGO.  It passes the
      request to the WebKDC with any single sign-on cookies as described
      above.  Go to step 5 if the user is authenticated, step 4 otherwise.

   4. Weblogin presents the username/password form with hidden fields as
      above.  User submits username/password, which is then validated.
      When successful, proceed to step 5.  The submit target of the form
      must be a URL not protected by SPNEGO (generally the same failure
      handler URL is reused).

   5. User is presented with a confirmation page as described above and
      can continue, authenticated, to the application.

Page Flow with Optional SPNEGO

  We want to instead allow the user to select whether to attempt SPNEGO or
  not, and to set a cookie that says to always use SPNEGO if desired.  To
  do that, we will use the following page flow:

   1. User is sent to Weblogin with tokens.  Weblogin passes the request
      and any single sign-on cookies to the WebKDC.  If the user is
      authenticated, go to step 6.  Otherwise, continue to step 2.

   2. Weblogin checks for the "always use SPNEGO" cookie.  If present
      *and* the application doesn't require username/password
      authentication, user is redirected to the configured SPNEGO URL,
      keeping the tokens at the end of the URL.  Go to step 3.  Otherwise,
      go to step 5.

   3. Apache attempts SPNEGO.  If successful, the user is passed to the
      login script with REMOTE_USER set.  Go to step 4.  Otherwise, the
      user is sent to the login script with a different URL (not SPNEGO
      protected) as a failure handler.  Go to step 5.

   4. The Weblogin script takes the REMOTE_USER value, cobbles up a single
      sign-on token, and passes that to the WebKDC.  If that's sufficient
      for authentication, proceed to step 6.  Otherwise, the
      username/password dialog is presented again.  Note that this case
      should not happen, since we catch applications that require
      username/password at step 2 and don't send them through the SPNEGO
      route.  But if it does, loop there until successful authentication,
      and then go to step 6.

   5. Either no SPNEGO cookie was available or SPNEGO was tried and
      failed.  In the latter case, read the token information out of the
      failure handler environment variables.  Present a username/password
      dialog box that also has an alternative that says to try SPNEGO, but
      suppress the latter if called as a failure handler since in that
      case we already tried it and it failed.  Loop until the user
      successfully authenticates with username/password and then go to
      step 6.

   6. The user has successfully authenticated.  Show the standard page
      with the link to the application.  Also show a check box indicating
      whether the "always use SPNEGO" cookie is present and a button that
      lets the user change that setting while returning them to the same
      confirmation page with the same link to the calling application.  We
      may want to suppress that check box if the user did not use SPNEGO
      *and* the SPNEGO cookie is not already set.  If it is set, that
      checkbox should always be presented.

Implementation

  In order to implement this page flow, the login.fcgi script uses the
  following logic:

   1. Check whether we have query data from either a GET or a POST.  If
      not, we may be running as an error handler.  Check to see if the
      environment variable REDIRECT_QUERY_STRING is set.  If so, set a
      flag saying we're running as an error handler and reinitialize the
      query using the contents of that variable as data.

   2. Make sure we have a request token RT and a webkdc-service token ST
      in the request.  If not, throw up the error page.

   3. If we already have return_url set in the query, we're at the
      confirmation page and the user has changed their SPNEGO
      configuration.  Set or clear the SPNEGO cookie as appropriate and
      then go to step 6 (displaying the confirmation page).  Otherwise,
      continue to step 4.

   4. Construct the message we're going to send to the WebKDC.  We always
      talk to the WebKDC unless we're already at the confirmation page,
      since the WebKDC may decide to authenticate the user at any step.
      The WebKDC request contains:

       * The request token from RT.
       * The webkdc-service token from ST.
       * The username and password if provided in the request (via a form
         submission, for instance).
       * Any tokens stored in cookies beginning with "webauth_wpt_".
         These are the single sign-on cookies.
       * Remote and local IP address and port information for logging.
       * If Apache REMOTE_USER support is enabled *and* REMOTE_USER is
         set, an additional single sign-on token manufactured from the
         identity in REMOTE_USER.

   5. Submit the request to the WebKDC and read the response.  Pull out
      the login cancel URL, if any, from the response no matter what and
      store it for later use.

   6. If the WebKDC said that the user is now authenticated, display the
      confirmation page.  Display the configuration checkbox for SPNEGO
      unless the SPNEGO cookie is not set *and* REMOTE_USER is not set
      (which means that either we attempted SPNEGO and failed or we never
      tried).  The configuration checkbox, if present, must contain all of
      the data required to rebuild the confirmation page, namely:

       * The return URL including response token and state token.
       * The authenticated username.
       * The login cancel token, if any.

      We do *not* have to preserve the proxy cookies, since we will have
      set them the first time through the confirm page.

   7. If we get this far, the user isn't authenticated yet.  There are
      five possibilities.

       * If the WebKDC returns a fatal error, display the error page and
         we're done.  They lose.

       * If the WebKDC returns WK_ERR_LOGIN_FAILED, they *do* have a
         "use SPNEGO" cookie, and we are not running as a failure handler,
         redirect to the configured SPNEGO URL, including the original
         request token and webkdc-service token in the URL.

       * If the WebKDC returns WK_ERR_LOGIN_FAILED, they do *not* have
         a "use SPNEGO" cookie, and we are not running as a failure
         handler, display the login page including the button that lets
         them try SPNEGO.

       * If the WebKDC returns WK_ERR_LOGIN_FAILED and neither of the
         above cases are true, we tried SPNEGO and it failed.  Display the
         login page but omit the button that lets them try SPNEGO.

       * If the WebKDC returns WK_ERR_USER_AND_PASS_REQUIRED, well,
         username and password are required.  We don't get to even try
         SPNEGO in this case.  Present the username/password dialog
         without the SPNEGO button.

Form Variables

  There are two basic templates used by the Weblogin script.  They must
  support the following HTML::Template variables:

  login.tmpl

      err_missinginput  If set, user didn't supply username and password
      err_username      If set, user didn't supply username
      err_password      If set, user didn't supply password
      login_failed      If set, login was invalid
      err_cookies       If set, user doesn't support cookies

      script_name       Relative URL to which form should be posted
      username          Username, if already known

      wa_cancel_url     If set, application provided a cancel URL
      cancel_url        The cancel URL (return URL plus cancel token)

      show_spnego       If set, show the option to try SPNEGO
      spnego_uri        Relative URL to which to send the user for SPNEGO

  confirm.tmpl

      username          Authenticated username
      return_url        Return URL, including response tokens
      pretty_return_url Anchor text for return URL (usually just host)

      login_cancel      If set, application provided a cancel URL
      cancel_url        The cancel URL (return URL plus cancel token)

      show_spnego       If set, show the SPNEGO cookie configuration
      spengo            Set to "checked" if SPNEGO desired, "" otherwise

  A different template is used in the event of some other WebKDC error.
  It takes the following HTML::Template variables:

  error.tmpl

      err_no_request_token      If set, user had no request token
      err_webkdc                If set, the WebKDC reported an error
      err_msg                   WebKDC error message

  The logout script and its template are not described here (yet).
