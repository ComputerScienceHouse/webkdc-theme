/* 
**  mod_webauth.c -- Apache sample webauth module
**  [Autogenerated via ``apxs -n webauth -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory 
**  by running:
**
**    $ apxs -c -i mod_webauth.c
**
**  Then activate it in Apache's httpd.conf file for instance
**  for the URL /webauth in as follows:
**
**    #   httpd.conf
**    LoadModule webauth_module modules/mod_webauth.so
**    <Location /webauth>
**    SetHandler webauth
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /webauth and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/webauth 
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 OK
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**  
**    The sample page from mod_webauth.c
*/ 

#include "mod_webauth.h"


#define CHUNK_SIZE 4096

/*
 * gather up the POST data as it comes back from webkdc
 */
static size_t
post_gather(void *in_data, size_t size, size_t nmemb,
            MWA_CURL_POST_GATHER_CTXT *ctxt)
{
    size_t real_size = size*nmemb;
    size_t needed_size = ctxt->size+real_size;

    if (ctxt->data == NULL || needed_size > ctxt->capacity) {
        char *new_data;
        while (ctxt->capacity < needed_size)
            ctxt->capacity += CHUNK_SIZE;

        new_data = apr_palloc(ctxt->r->pool, ctxt->capacity);

        if (ctxt->data != NULL) {
            memcpy(new_data, ctxt->data, ctxt->size);
        } 
        /* don't have to free existing data since it from a pool */
        ctxt->data = new_data;
    }
    memcpy(ctxt->data+ctxt->size, in_data, real_size);
    ctxt->size += real_size;
    return real_size;
}

/*
 * check cookie for valid app-token. If an epxired one is found,
 * do a Set-Cookie (in fixups) to blank it out.
 */
static char *
post_to_webkdc(char *post_data, int post_data_len, request_rec *r, 
               MWA_SCONF *sconf, MWA_DCONF *dconf)
{
    CURL *curl;
    CURLcode code;
    char curl_error_buff[CURL_ERROR_SIZE+1];
    struct curl_slist *headers=NULL;
    MWA_CURL_POST_GATHER_CTXT pgc;

    if (post_data_len == 0)
        post_data_len = strlen(post_data);

    curl = curl_easy_init();

    if (curl == NULL) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: post_to_webkdc: curl_easy_init failed");
        return NULL;
    }

    curl_easy_setopt(curl, CURLOPT_URL, sconf->webkdc_url);
    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1);
    curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1);
    curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, curl_error_buff);

    /* FIXME: turning this off for testing! */
    ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                 "mod_webauth: WARNING: USING CURLOPT_SSL_VERIFYPEER 0!");
    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0);

    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, post_gather);

    /* don't pre-allocate in case our write function never gets called */
    pgc.data = 0;
    pgc.size = 0;
    pgc.capacity = 0;
    pgc.r = r;
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &pgc);
    headers = curl_slist_append(headers, "Content-Type: text/xml");
 
    /* data to post */
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post_data);
 
    /* set the size of the postfields data */
    curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, post_data_len);
 
    /* pass our list of custom made headers */
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
 
    curl_error_buff[0] = '\0';
    code = curl_easy_perform(curl); /* post away! */
 
    curl_slist_free_all(headers); /* free the header list */

    if (code != CURLE_OK) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: curl_easy_perform: error(%d): %s",
                     code, curl_error_buff);
        return NULL;
    }
    /* null-terminate return data */
    if (pgc.data) {
        pgc.data[pgc.size] = '\0';
    }
    curl_easy_cleanup(curl);
    return pgc.data;
}

void
log_webauth_krb5_error(request_rec *r, 
                       int status, 
                       WEBAUTH_KRB5_CTXT *ctxt,
                       const char *mwa_func,
                       const char *func)
{
    if (status == WA_ERR_KRB5) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: %s: %s failed: %s (%d): %s %d",
                     mwa_func, func,
                     webauth_error_message(status), status,
                     webauth_krb5_error_message(ctxt), 
                     webauth_krb5_error_code(ctxt));
    } else {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: %s: %s failed: %s (%d)",
                     webauth_error_message(status), status);
    }
}

/*
 * get a WEBAUTH_KRB5_CTXT
 */
static WEBAUTH_KRB5_CTXT *
get_webauth_krb5_ctxt(request_rec *r, const char *mwa_func)
{
    WEBAUTH_KRB5_CTXT *ctxt;
    int status;

    status = webauth_krb5_new(&ctxt);
    if (status != WA_ERR_NONE) {
        log_webauth_krb5_error(r, status, ctxt, mwa_func, "webauth_krb5_new");
        if (status == WA_ERR_KRB5)
            webauth_krb5_free(ctxt);
        return NULL;
    }
    return ctxt;
}

/*
 * FIXME: all the data might not be in first_cdata.first, need to investigate
 */
static const char *
get_elem_text(apr_xml_elem *e, const char *def)
{
    if (e->first_cdata.first &&
        e->first_cdata.first->text) {
        return e->first_cdata.first->text;
    } else {
        return def;
    }
}

/*
 * XXX
 */
static void
log_error_response(apr_xml_elem *e,
                   const char *mwa_func,
                   request_rec *r)
{
    apr_xml_elem *sib;
    const char *error_code = "(no error_code)";
    const char *error_message = "(no error message)";

    for (sib = e->first_child; sib; sib = sib->next) {
        if (strcmp(sib->name, "errorCode") == 0) {
            error_code = get_elem_text(sib, error_code);
        } else if (strcmp(sib->name, "errorMessage") == 0) {
            error_message = get_elem_text(sib, error_message);
        } else {
            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, 
                         "mod_webauth: log_error_response: "
                         "ignoring unknown element in <errorResponse>: <%s>",
                         sib->name);
        }
    }
    ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, 
                 "mod_webauth: %s: errorResponse from webkdc: errorCode(%s) "
                 "errorMessage(%s)",
                 mwa_func, error_code, error_message);

}

/*
 * pass in st_pool in case we want service token in process pool
 */
static MWA_SERVICE_TOKEN *
parse_service_token_response(apr_xml_doc *xd,
                             apr_pool_t *st_pool,
                             request_rec *r, 
                             MWA_SCONF *sconf, MWA_DCONF *dconf)
{
    MWA_SERVICE_TOKEN *st;
    apr_xml_elem *e, *sib;
    static const char *mwa_func = "parse_service_token_response";
    const char *expires, *session_key, *token_data;
    
    e = xd->root;

    if (strcmp(e->name, "errorResponse") == 0) {
        log_error_response(e, mwa_func, r);
        return NULL;
    } else if (strcmp(e->name, "getTokensResponse") != 0) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, 
                     "mod_webauth: %s: unknown response(%s)", 
                     mwa_func, e->name);
        return NULL;
    }

    /* parse it already */
    e = e->first_child;
    if (!e || strcmp(e->name, "tokens") != 0) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, 
                     "mod_webauth: %s: can't find <tokens>", 
                     mwa_func, e->name);
        return NULL;
    }

    e = e->first_child;
    if (!e || strcmp(e->name, "token") != 0) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, 
                     "mod_webauth: %s: can't find <token>", 
                     mwa_func, e->name);
        return NULL;
    }

    session_key = expires = token_data = NULL;

    for (sib = e->first_child; sib; sib = sib->next) {
        if (strcmp(sib->name, "sessionKey") == 0) {
            session_key = get_elem_text(sib, NULL);
        } else if (strcmp(sib->name, "expires") == 0) {
            expires = get_elem_text(sib, NULL);
        } else if (strcmp(sib->name, "tokenData") == 0) {
            token_data = get_elem_text(sib, NULL);
        } else {
            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, 
                         "mod_webauth: %s: "
                         "ignoring unknown element in <token>: <%s>",
                         mwa_func, sib->name);
        }
    }

    if ((session_key == NULL) || (expires == NULL) || (token_data == NULL)) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, 
                     "mod_webauth: %s: "
                     "missing %s%s%s",
                     mwa_func, 
                     session_key == NULL ? "<sessionKey> " : "",
                     expires == NULL ? "<expires> " : "",
                     token_data == NULL ? "<tokenData> " : "");
        return NULL;
    }

    st = (MWA_SERVICE_TOKEN *) apr_palloc(st_pool, sizeof(MWA_SERVICE_TOKEN));
    st->expires = atoi(expires);
    st->token = apr_pstrdup(st_pool, token_data);
    st->key = (WEBAUTH_KEY*) apr_palloc(st_pool, sizeof(WEBAUTH_KEY));
    /* FIXME: key type could be a conf file directive */
    st->key->type = WA_AES_KEY;
    st->key->data = (unsigned char*)
        apr_palloc(st_pool, apr_base64_decode_len(session_key));
    st->key->length = apr_base64_decode(st->key->data, session_key);
    if (st->key->length != WA_AES_128 && 
        st->key->length != WA_AES_192 &&
        st->key->length != WA_AES_256) {
        /* bummer, after all that work too :) */
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, 
                     "mod_webauth: %s: "
                     "invalid sessionKey length after base64 decode: %d",
                     mwa_func, st->key->length);
        return NULL;
    }
    return st;
}

/*
 * XXX
 */
MWA_SERVICE_TOKEN *
request_service_token(request_rec *r, 
                      apr_pool_t *st_pool,
                      MWA_SCONF *sconf, MWA_DCONF *dconf)
{
    WEBAUTH_KRB5_CTXT *ctxt;
    apr_xml_parser *xp;
    apr_xml_doc *xd;
    char *xml_request, *xml_response;
    unsigned char *k5_req, *bk5_req;
    int status, k5_req_len, bk5_req_len;
    static const char *mwa_func = "request_service_token";
    apr_status_t astatus;

    ctxt = get_webauth_krb5_ctxt(r, mwa_func);
    if (ctxt == NULL)
        return 0;

    status = webauth_krb5_init_via_keytab(ctxt, sconf->keytab_path, NULL);
    if (status != WA_ERR_NONE) {
        log_webauth_krb5_error(r, status, ctxt, mwa_func,
                               "webauth_krb5_init_via_keytab");
        webauth_krb5_free(ctxt);
        return 0;
    }

    status = webauth_krb5_mk_req(ctxt, sconf->webkdc_principal, 
                                 &k5_req, &k5_req_len);
    webauth_krb5_free(ctxt);

    if (status != WA_ERR_NONE) {
        log_webauth_krb5_error(r, status, ctxt, mwa_func,
                               "webauth_krb5_mk_req");
        return 0;
    }

    bk5_req_len = apr_base64_encode_len(k5_req_len);
    bk5_req = (char*) apr_palloc(r->pool, bk5_req_len);
    apr_base64_encode(bk5_req, k5_req, k5_req_len);
    free(k5_req);
    
    xml_request = apr_pstrcat(r->pool, 
                              "<getTokensRequest>"
                              "<requesterCredential type='krb5'>",
                              bk5_req,
                              "</requesterCredential>"
                              "<tokens><token type='service'/></tokens>"
                              "</getTokensRequest>",
                              NULL);

    ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, 
                 "mod_webauth: xml_request(%s)", xml_request);


    xml_response = post_to_webkdc(xml_request, 0, r, sconf, dconf);

    if (xml_response == NULL)
        return 0;

    ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, 
                 "mod_webauth: xml_response(%s)", xml_response);

    
    xp = apr_xml_parser_create(r->pool);
    if (xp == NULL) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, 
                     "mod_webauth: %s: apr_xml_parser_create failed", 
                     mwa_func);
        return 0;
    }

    astatus = apr_xml_parser_feed(xp, xml_response, strlen(xml_response));
    if (astatus == APR_SUCCESS) {
        astatus = apr_xml_parser_done(xp, &xd);
    }

    if (astatus != APR_SUCCESS) {
        char errbuff[1024];
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, 
                     "mod_webauth: %s: "
                     "apr_xml_parser_{feed,done} failed: %s (%d)", 
                     mwa_func,
                     apr_xml_parser_geterror(xp, errbuff, sizeof(errbuff)),
                     astatus);
        return 0;
    }

    ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, 
                 "mod_webauth: xml doc root(%s)", xd->root->name);

   return parse_service_token_response(xd, st_pool, r, sconf, dconf);
}

/*
 * get a required char* attr from a token, with logging if not present.
 * returns value or NULL on error,
 */
const char *
get_str_attr(WEBAUTH_ATTR_LIST *alist, char *name, request_rec *r, char *func)
{
    int status, i;

    status = webauth_attr_list_find(alist, name, &i);
    if (i == -1) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: %s: can't find attr(%s) in token",
                     func, name);
        return NULL;
    }
    return (const char*)alist->attrs[i].value;
}

/*
 * get note from main request 
 */
const char *
get_note(request_rec *r, const char *note)
{
    if (r->main) {
        return apr_table_get(r->main->notes, note);
    } else {
        return apr_table_get(r->notes, note);
    }
}

/*
 * remove note from main request, and return it if it was set, or NULL
 * if unset
 */
static char *
remove_note(request_rec *r, const char *note)
{
    const char *val;
    if (r->main)
        r = r->main;

    val = apr_table_get(r->notes, note);

    if (val != NULL)
        apr_table_unset(r->notes, note);

    return (char*)val;
}

/*
 * set note to main request. does not make copy of data
 */
static void
setn_note(request_rec *r, const char *note, const char *val)
{
    if (r->main) {
        apr_table_setn(r->main->notes, note, val);
    } else {
        apr_table_setn(r->notes, note, val);
    }
}


/*
 * log interesting stuff from the request
 */
static void 
log_request(request_rec *r, const char *msg)
{

    /* FIXME: disabling for now */
    return;

#define LOG_S(a,b) ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, \
              "mod_webauth: %s(%s)", a, (b != NULL)? b:"(null)");
#define LOG_D(a,b) ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, \
              "mod_webauth: %s(%d)", a, b);

    ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                 "mod_webauth: -------------- %s ------------------", msg);

    LOG_S("ap_auth_type", ap_auth_type(r));
    LOG_S("the_request", r->the_request);
    LOG_S("unparsed_uri", r->unparsed_uri);
    LOG_S("uri", r->uri);
    LOG_S("filename", r->filename);
    LOG_S("canonical_filename", r->canonical_filename);
    LOG_S("path_info", r->path_info);
    LOG_S("args", r->args);
    LOG_D("rpu->is_initialized", r->parsed_uri.is_initialized);
    LOG_S("rpu->query", r->parsed_uri.query);

    ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                 "mod_webauth: -------------- %s ------------------", msg);

#undef LOG_S
#undef LOG_D
}

static int 
die(const char *message, server_rec *s)
{
    if (s) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
                     "mod_webauth: fatal error: %s", message);
    }
    printf("mod_webauth: fatal error: %s\n", message);
    exit(1);
}


/*
 * module cleanup
 */
static apr_status_t
mod_webauth_cleanup(void *data)
{
    MWA_SCONF *sconf = (MWA_SCONF*) data;

    if (sconf->ctxt == NULL)
        return APR_SUCCESS;

    if (sconf->ctxt->ring != NULL) {
        webauth_keyring_free(sconf->ctxt->ring);
    }
    return APR_SUCCESS;
}

/*
 * called after config has been loaded in parent process
 */
static int
mod_webauth_init(apr_pool_t *pconf, apr_pool_t *plog,
                 apr_pool_t *ptemp, server_rec *s)
{
    MWA_SCONF *sconf;
    MWA_SCTXT *sctxt;
    int status;

    sconf = (MWA_SCONF*)ap_get_module_config(s->module_config,
                                                 &webauth_module);

    ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, "mod_webauth: initializing");

#define CHECK_DIR(field,dir) if (sconf->field == NULL) \
             die(apr_psprintf(ptemp, "directive %s must be set", dir), s)

    CHECK_DIR(login_url, CD_LoginURL);
    CHECK_DIR(keyring_path, CD_Keyring);
    CHECK_DIR(webkdc_url, CD_WebKDCURL);
    CHECK_DIR(keytab_path, CD_Keytab);
    CHECK_DIR(webkdc_principal, CD_WebKDCPrincipal);

#undef CHECK_DIR

    /* register pool cleanup function */
    apr_pool_cleanup_register(pconf, sconf, mod_webauth_cleanup, 
                              apr_pool_cleanup_null);


    sctxt = (MWA_SCTXT *) apr_palloc(pconf, sizeof(MWA_SCTXT));

    /* attempt to open up keyring */
    status = webauth_keyring_read_file(sconf->keyring_path, &sctxt->ring);
    if (status != WA_ERR_NONE) {
        die(apr_psprintf(ptemp, 
                 "mod_webauth: webauth_keyring_read_file(%s) failed: %s (%d)",
                         sconf->keyring_path, webauth_error_message(status), 
                         status), s);
    } else {
        /* FIXME: should probably make sure we have at least one
           valid (not expired/postdated) key in the ring */
    }

    /* stash the sctxt in the server's process pool */
    apr_pool_userdata_set(sctxt, P_MWA_SCTXT, 
                          apr_pool_cleanup_null, s->process->pool);

    ap_add_version_component(pconf, WEBAUTH_VERSION);

    ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, "mod_webauth: initialized");

    return OK;
}

/*
 * called once per-child
 */
static void
mod_webauth_child_init(apr_pool_t *p, server_rec *s)
{
    /*
      MWA_SCONF *sconf;

      sconf = (MWA_SCONF*)ap_get_module_config(s->module_config,
      &webauth_module);

     ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, "mod_webauth: child_init_hook");
    */
}

/*
**
**  per-server configuration structure handling
**
*/

static void *
config_server_create(apr_pool_t *p, server_rec *s)
{
    MWA_SCONF *sconf;

    sconf = (MWA_SCONF*)apr_pcalloc(p, sizeof(MWA_SCONF));

    /* only one with a non-zero default */
    sconf->secure_cookie = DF_SecureCookie;
    sconf->token_max_ttl = DF_TokenMaxTTL;

    /* grab server context too */
    apr_pool_userdata_get((void*)&sconf->ctxt, P_MWA_SCTXT, s->process->pool);

    return (void *)sconf;
}

static void *
config_dir_create(apr_pool_t *p, char *path)
{
    MWA_DCONF *dconf;
    dconf = (MWA_DCONF*)apr_pcalloc(p, sizeof(MWA_DCONF));
    /* no defaults */
    return (void *)dconf;
}


#define MERGE_PTR(field) \
    conf->field = (oconf->field != NULL) ? oconf->field : bconf->field

#define MERGE_INT(field) \
    conf->field = oconf->field ? oconf->field : bconf->field

static void *
config_server_merge(apr_pool_t *p, void *basev, void *overv)
{
    MWA_SCONF *conf, *bconf, *oconf;

    conf = (MWA_SCONF*) apr_pcalloc(p, sizeof(MWA_SCONF));
    bconf = (MWA_SCONF*) basev;
    oconf = (MWA_SCONF*) overv;

    /* secure_cookie is 1 by default, so we need to check if
       it was explicitly set in the override */
    
    conf->secure_cookie = oconf->secure_cookie_ex ?
        oconf->secure_cookie : bconf->secure_cookie;

    conf->token_max_ttl = oconf->token_max_ttl_ex ?
        oconf->token_max_ttl : bconf->token_max_ttl;

    MERGE_PTR(webkdc_url);
    MERGE_PTR(webkdc_principal);
    MERGE_PTR(login_url);
    MERGE_PTR(failure_url);
    MERGE_PTR(keyring_path);
    MERGE_PTR(keytab_path);
    MERGE_PTR(st_cache_path);
    MERGE_PTR(var_prefix);
    MERGE_INT(debug);
    MERGE_PTR(ctxt);

    return (void *)conf;
}

static void *
config_dir_merge(apr_pool_t *p, void *basev, void *overv)
{
    MWA_DCONF *conf, *bconf, *oconf;

    conf = (MWA_DCONF*) apr_pcalloc(p, sizeof(MWA_DCONF));
    bconf = (MWA_DCONF*) basev;
    oconf = (MWA_DCONF*) overv;

    MERGE_INT(app_token_lifetime);
    MERGE_PTR(subject_auth_type);
    MERGE_INT(inactive_expire);
    MERGE_INT(force_login);
    MERGE_PTR(return_url);
    return (void *)conf;
}

#undef MERGE_PTR
#undef MERGE_INT

/* The sample content handler */
static int 
handler_hook(request_rec *r)
{
    if (strcmp(r->handler, "webauth")) {
        return DECLINED;
    }
    r->content_type = "text/html";      

    if (!r->header_only)
        ap_rputs("The sample page from mod_webauth.c\n", r);
    return OK;
}

static WEBAUTH_ATTR_LIST *
parse_app_token(char *token,
                request_rec *r,
                MWA_SCONF *sconf, MWA_DCONF *dconf)
{
    WEBAUTH_ATTR_LIST *alist;
    int blen, status, i;
    const char *tt;

    ap_unescape_url(token);
    blen = apr_base64_decode(token, token);

    /* parse the token, TTL is zero because app-tokens don't have ttl,
     * just expiration
     */
    status = webauth_token_parse(token, blen, 0, sconf->ctxt->ring, &alist);
    if (status != WA_ERR_NONE) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: webauth_token_parse failed: %s (%d)",
                     webauth_error_message(status), 
                     status);
        return NULL;
    }

    /* make sure its an app-token */
    tt = get_str_attr(alist, WA_TK_TOKEN_TYPE, r, "check_cookie");
    if (strcmp(tt, WA_TT_APP) != 0) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: check_cookie: token type(%s) not (%s)",
                     (char*)alist->attrs[i].value, WA_TT_APP);
        webauth_attr_list_free(alist);
        return NULL;
    }
    return alist;
}

/*
 * check cookie for valid app-token. If an epxired one is found,
 * do a Set-Cookie (in fixups) to blank it out.
 */
static char *
check_cookie(request_rec *r, MWA_SCONF *sconf, MWA_DCONF *dconf)
{
    const char *c;
    char *cs, *ce, *cval, *sub;
    int status, blen;
    int i;
    WEBAUTH_ATTR_LIST *alist;

    c = apr_table_get(r->headers_in, "Cookie");
    if (c == NULL) 
        return NULL;

    cs = ap_strstr(c, AT_COOKIE_NAME_EQ);
    if (cs == NULL) {
        return NULL;
    } else {
        cs += sizeof(AT_COOKIE_NAME_EQ)-1;
    }

    ce = ap_strchr(cs, ';');

    if (ce == NULL) {
        cval = apr_pstrdup(r->pool, cs);
    } else {
        cval = apr_pstrmemdup(r->pool, cs, ce-cs);
    }

    sub = NULL;

    alist = parse_app_token(cval, r, sconf, dconf);
    if (alist != NULL) {
        /* pull out subject */
        const char *tsub = 
            get_str_attr(alist, WA_TK_SUBJECT, r, "check_cookie");
        if (tsub != NULL) {
            sub = apr_pstrdup(r->pool, tsub);
        }
        webauth_attr_list_free(alist);
    }

    if (sub == NULL) {
        /* we coudn't use the cookie, lets set it up to be nuked */
        char *cookie = apr_psprintf(r->pool,
                                    "%s=; path=/; expires=%s;%s",
                                    AT_COOKIE_NAME,
                                    "Thu, 26-Mar-1998 00:00:01 GMT",
                                    sconf->secure_cookie ? "secure" : "");
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: nuking cookie(%s): (%s)\n", 
                     AT_COOKIE_NAME, cookie);
        setn_note(r, N_APP_COOKIE, cookie);
        return NULL;
    }

    if (sub != NULL) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: found valid %s cookie for (%s)", 
                     AT_COOKIE_NAME,
                     sub);

    }
    return sub;
}

WEBAUTH_KEY *
get_session_key(char *token,
                request_rec *r,
                MWA_SCONF *sconf,
                MWA_DCONF *dconf)
{
    WEBAUTH_ATTR_LIST *alist;
    WEBAUTH_KEY *key;
    int status, i;

    alist = parse_app_token(token, r, sconf, dconf);

    if (alist == NULL)
        return NULL;

    /* pull out session key */
    status = webauth_attr_list_find(alist, WA_TK_SESSION_KEY, &i);
    if (i == -1) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, 
                    "mod_webauth: check_url: can't find session key in token");
        webauth_attr_list_free(alist);
        return NULL;
    }

    key = webauth_key_create(WA_AES_KEY,
                             (unsigned char*)alist->attrs[i].value,
                             alist->attrs[i].length);
    webauth_attr_list_free(alist);
    if (key == NULL) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
           "mod_webauth: check_url: can't find session key in WEBAUTHS token");
    }
    return key;
}

static char *
validate_krb5_sad(WEBAUTH_ATTR_LIST *alist,
                  request_rec *r,
                  MWA_SCONF *sconf, 
                  MWA_DCONF *dconf)
{
    WEBAUTH_KRB5_CTXT *ctxt;
    int status, i;
    char *principal, *subject;

    status = webauth_attr_list_find(alist, WA_TK_SUBJECT_AUTH_DATA, &i);
    if (i == -1) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, 
                     "mod_webauth: validate_krb5_sad: "
                     "can't find subject auth data");
        return NULL;
    }

    ctxt = get_webauth_krb5_ctxt(r, "validate_krb5_sad");
    if (ctxt == NULL)
        return NULL;

    status = webauth_krb5_rd_req(ctxt,
                                 alist->attrs[i].value,
                                 alist->attrs[i].length,
                                 sconf->keytab_path,
                                 &principal);

    webauth_krb5_free(ctxt);

    if (status != WA_ERR_NONE) {
        log_webauth_krb5_error(r, status, ctxt, "validate_krb5_sad",
                               "webauth_krb5_rd_req");
        return NULL;
    }

    subject = apr_pstrcat(r->pool, "krb5:", principal, NULL);
    free(principal);
    return subject;
}

static void
make_app_token(char *subject,
               time_t expiration_time,
               request_rec *r, 
               MWA_SCONF *sconf, 
               MWA_DCONF *dconf)
{
    WEBAUTH_ATTR_LIST *alist = webauth_attr_list_new(10);
    time_t curr = time(NULL);
    char *token, *btoken, *cookie;
    int tlen, olen, status;

    if (alist == NULL) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: make_app_token: "
                     "webauth_attr_list_new failed");
        return;
    }

    if (dconf->app_token_lifetime) {
        expiration_time = curr+dconf->app_token_lifetime;
    }

    webauth_attr_list_add_str(alist, WA_TK_TOKEN_TYPE, WA_TT_APP, 0, 0);
    webauth_attr_list_add_str(alist, WA_TK_SUBJECT, subject, 0, 0);
    webauth_attr_list_add_time(alist, WA_TK_EXPIRATION_TIME,
                               expiration_time, 0);

    webauth_attr_list_add_time(alist, WA_TK_CREATION_TIME, curr, 0);
    
    /* FIXME: handle it/lt app_token_lifetime, inactive/etc */

    tlen = webauth_token_encoded_length(alist);
    token = (char*)apr_palloc(r->pool, tlen);

    status = webauth_token_create(alist, curr, token, &olen, tlen,
                                  sconf->ctxt->ring);
    webauth_attr_list_free(alist);

    if (status != WA_ERR_NONE) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: make_app_token failed: %s (%d)",
                     webauth_error_message(status), 
                     status);
        return;
    }

    btoken = (char*) apr_palloc(r->pool, apr_base64_encode_len(olen));
    apr_base64_encode(btoken, token, olen);

    cookie = apr_psprintf(r->pool,
                          "%s=%s; path=/;%s",
                          AT_COOKIE_NAME,
                          btoken,
                          sconf->secure_cookie ? "secure" : "");
    ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                 "mod_webauth: make_app_token setting cookie(%s): (%s)\n", 
                 AT_COOKIE_NAME, cookie);
    setn_note(r, N_APP_COOKIE, cookie);
}


static char *
handle_id_token(WEBAUTH_ATTR_LIST *alist,
                request_rec *r, 
                MWA_SCONF *sconf, 
                MWA_DCONF *dconf)
{
    char *subject;
    int status;
    const char *sa = get_str_attr(alist, WA_TK_SUBJECT_AUTH,
                                  r, "parse_returned_token");
    if (sa == NULL ) {
        /* nothing, we already logged an error */
        return NULL;
    }

    if (strcmp(sa, WA_SA_KRB5) == 0) {
        subject = validate_krb5_sad(alist, r, sconf, dconf);
    } else if (strcmp(sa, WA_SA_WEBKDC) == 0) {
        /* subject is all set */
        const char *tsub = get_str_attr(alist, WA_TK_SUBJECT,
                                        r, "parse_returned_token");
        subject = apr_pstrdup(r->pool, tsub);
    } else {

    }
        
    if (subject != NULL) {
        time_t expiration_time;
        /* wheeee! create an app-token! */

        status = webauth_attr_list_get_time(alist, WA_TK_EXPIRATION_TIME,
                                            &expiration_time);
        if (status != WA_ERR_NONE) {
            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                         "mod_webauth: parse_returned_token: "
                         "can't get expiration time from id token token");
        } else {
            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                         "mod_webauth: parse_returned_token: "
                         "got subject(%s) from id token", subject);
            make_app_token(subject, expiration_time,
                           r, sconf, dconf);
        }
    } else {
        /* FIXME: everyone else should have logged something, right? */
    }
    return subject;
}



static char *
parse_returned_token(char *token,
                     WEBAUTH_KEY *key,
                     request_rec *r, 
                     MWA_SCONF *sconf, 
                     MWA_DCONF *dconf)
{
    WEBAUTH_ATTR_LIST *alist;
    int blen, status;
    const char *token_type;
    char *subject;

    subject = NULL;

    /* if we successfully parse an id-token, write out new webauth_at cookie */
    ap_unescape_url(token);
    blen = apr_base64_decode(token, token);

    status = webauth_token_parse_with_key(token, blen, 
                                 sconf->token_max_ttl, key, &alist);

    if (status != WA_ERR_NONE) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: parse_returned_token: "
                     "webauth_token_parse failed: %s (%d)",
                     webauth_error_message(status), 
                     status);
        return NULL;
    }

    /* make sure its an app-token */
    token_type = get_str_attr(alist, WA_TK_TOKEN_TYPE, r, 
                              "parse_returned_token");
    if (token_type == NULL) {
        webauth_attr_list_free(alist);
        return NULL;
    }

    if (strcmp(token_type, WA_TT_ID) == 0) {

        subject = handle_id_token(alist, r, sconf, dconf);

    } else if (strcmp(token_type, WA_TT_PROXY) == 0) {

        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: parse_returned_token: "
                     "parsed a proxy token");

    } else if (strcmp(token_type, WA_TT_ERROR) == 0) {

        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: parse_returned_token: "
                     "parsed an error token");

    } else {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: parse_returned_token: "
                     "unhandled token type(%s)", token_type);
    }
    webauth_attr_list_free(alist);

    return subject;
}

/*
 * check to see if we got passed WEBAUTHR and WEBAUTHS
 */
static char *
check_url(request_rec *r, MWA_SCONF *sconf, MWA_DCONF *dconf)
{
    char *subject, *wr, *ws;
    WEBAUTH_KEY *key = NULL;

    wr = remove_note(r, N_WEBAUTHR);
    if (wr == NULL) {
        return NULL;
    }

    ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                 "mod_webauth: check_url: found wr(%s)", wr);

    /* see if we have WEBAUTHS, which has the session key to use */
    ws = remove_note(r, N_WEBAUTHS);

    if (ws != NULL) {
        key = get_session_key(ws, r, sconf, dconf);
        if (key == NULL)
            return NULL;
        subject = parse_returned_token(wr, key, r, sconf, dconf);
        webauth_key_free(key);
    } else {
        /* FIXME: use key from session-token */
        /* subject = parse_returned_token(wr, key, r, sconf, dconf); */
        subject = NULL;
    }
    return subject;
}

static int 
check_user_id_hook(request_rec *r)
{
    const char *at = ap_auth_type(r);
    const char *subject, *cookie;
    MWA_SCONF *sconf;
    MWA_DCONF *dconf;

    dconf = (MWA_DCONF*)ap_get_module_config(r->per_dir_config,
                                                 &webauth_module);

    sconf = (MWA_SCONF*)ap_get_module_config(r->server->module_config,
                                                 &webauth_module);

    ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                 "mod_webauth: in check_user_id hook");

    if ((at == NULL) || (strcmp(at, "WebAuth") != 0)) {
        return DECLINED;
    }

    /* first check if we've already validated the user */
    subject = get_note(r, N_SUBJECT);

    if (subject == NULL) {
        /* next, check for valid app-token cookie */
        subject = check_cookie(r, sconf, dconf);

        if (subject == NULL) {
            /* if no valid app token, look for WEBAUTHR in url */
            subject = check_url(r, sconf, dconf);
        }
        /* stick it in note for future reference */
        if (subject != NULL)
            setn_note(r, N_SUBJECT, subject);
    }

    /* see if we have to update our cookie and save it in err_headers_out
     * so it always gets sent. check_cookie and check_url both will
     * set the N_APP_COOKIE note if they need a new cooke 
     */

    if (cookie = remove_note(r, N_APP_COOKIE))
        apr_table_addn(r->err_headers_out, "Set-Cookie", cookie);

    if (subject != NULL) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: check_user_id_hook setting user(%s)",
                     subject);
        r->user = (char*)subject;
        r->ap_auth_type = (char*)at;
        return OK;
    } else {
        /* we would normally redirect at this point */
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: check_user_id_hook: no valid user found");
        return HTTP_UNAUTHORIZED;
    }

    /* FIXME: would normally return DECLINED at this point */
    /* FIXME: hack test for redirect handling */
    if ((r->args != NULL) && (*(r->args) == 'Z')) {
    ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                 "mod_webauth: set Location, returning redirect...");
    apr_table_setn(r->err_headers_out, "Location", sconf->login_url);
        return HTTP_MOVED_TEMPORARILY;
    } else {
        return OK;
    }
}

static int 
auth_checker_hook(request_rec *r)
{
    return DECLINED;
}

static void
strip_end(char *c, char *t)
{
    char *p;
    if (c != NULL) {
        p = ap_strstr(c, t);
        if (p != NULL)
            *p = '\0';
    }
}

/*
 * this hook will attempt to find the returned-token and the
 * state-token in the URL. If we find them and stash them in 
 * the notes for the master request, and then remove them from 
 * everywhere we find them, including the r->the_request, so they 
 * don't show up in access_logs.
 *
 *  we check in the following places:
 *    r->the_request
 *    r->unparsed_uri
 *    r->uri
 *    r->filename
 *    r->canonical_filename
 *    r->path_info
 *    r->args
 *    r->parsed_uri.path
 *    r->parsed_uri.query
 *
 *  we'll stick the token in the notes table for the initial
 *  request
 *  
 */
static int 
translate_name_hook(request_rec *r)
{
    char *p, *s, *rp;
    char *wr, *ws;

    static char *rmagic = WEBAUTHR_MAGIC;
    static char *smagic = WEBAUTHS_MAGIC;

    /*
      ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, 
      "mod_webauth: translate_name_hook disabled for now");
      return DECLINED;
    */

    if (!ap_is_initial_req(r)) {
        return DECLINED;
    }

    log_request(r, "before xlate");

    rp = ap_strstr(r->the_request, rmagic);
    if (rp == NULL) {
        /* no tokens in the request, return */
        return DECLINED;
    }

    /* we need to save the tokens for check_user_id_hook. */

    s = rp+WEBAUTHR_MAGIC_LEN;
    p = ap_strchr(s, ';');
    if (p == NULL) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: didn't find end of %s", rmagic);
        return DECLINED;
    }
    wr = apr_pstrmemdup(r->pool, s, p-s);
    ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, 
                 "mod_webauth: stash wr(%s)", wr);
    setn_note(r, N_WEBAUTHR, wr);

    s = p+1;
    p = ap_strstr(s, smagic);
    if (p != NULL) {
        s = p+WEBAUTHS_MAGIC_LEN;
        p = ap_strchr(s, ';');
        if (p == NULL) {
            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                         "mod_webauth: didn't find end of %s", smagic);
            return DECLINED;
        }
        ws = apr_pstrmemdup(r->pool, s, p-s);
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: stash ws(%s)", ws);
        setn_note(r, N_WEBAUTHS, ws);
        s = p+1;
    }
    /* move over remaining */
    strcpy(rp, s);
    
    /* these are easier, we strip rmagic and everything after it, 
       which might include smagic */

    strip_end(r->unparsed_uri, rmagic);
    strip_end(r->uri, rmagic);
    strip_end(r->filename, rmagic);
    strip_end(r->canonical_filename, rmagic);
    strip_end(r->path_info, rmagic);
    strip_end(r->args, rmagic);
    strip_end(r->parsed_uri.path, rmagic);
    strip_end(r->parsed_uri.query, rmagic);

    log_request(r, "after xlate");

    /* still need to return DECLINED, so other modules (like mod_rerewrite)
       get a crack at things */
    return DECLINED;
}

static int 
fixups_hook(request_rec *r)
{
    MWA_DCONF *dconf;
    MWA_SCONF *sconf;
    const char *subject;

    dconf = (MWA_DCONF*)ap_get_module_config(r->per_dir_config,
                                                 &webauth_module);

    sconf = (MWA_SCONF*)ap_get_module_config(r->server->module_config,
                                                 &webauth_module);

    if (ap_is_initial_req(r)) {
        char *new_cookie;
        const char *at;
        /*new_cookie = apr_psprintf(r->pool, "MOD_WEBAUTH=%d; path=/",
                                  apr_time_now());
        apr_table_setn(r->headers_out, "Set-Cookie", new_cookie);
        */
        log_request(r, "in fixups");
    } else {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, 
                     "mod_webauth: subreq fixups url(%s)", r->unparsed_uri);
    }

    /* set environment variable */
    subject = get_note(r, N_SUBJECT);
    if (subject) {

        char *name;
        if (sconf->var_prefix) {
            name = apr_pstrcat(r->pool, sconf->var_prefix, 
                               ENV_WEBAUTH_USER, NULL);
        } else {
            name = ENV_WEBAUTH_USER;
        }
        apr_table_setn(r->subprocess_env, name, subject);
        {
            MWA_SERVICE_TOKEN *st = 
                request_service_token(r, r->pool, sconf, dconf);
            if (st != NULL) {
                ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, 
                             "mod_webauth: st->expires(%d)", st->expires);
            }
        }
    }
    return DECLINED;
}


static const char *
cfg_str(cmd_parms *cmd, void *mconf, const char *arg)
{
    int e = (int)cmd->info;
    char *error_str = NULL;
    MWA_DCONF *dconf = (MWA_DCONF *)mconf;

    MWA_SCONF *sconf = (MWA_SCONF *)
        ap_get_module_config(cmd->server->module_config, &webauth_module);
    
    switch (e) {
        /* server configs */
        case E_WebKDCURL:
            sconf->webkdc_url = apr_pstrdup(cmd->pool, arg);
            break;
        case E_WebKDCPrincipal:
            sconf->webkdc_principal = apr_pstrdup(cmd->pool, arg);
            break;
        case E_LoginURL:
            sconf->login_url = apr_pstrdup(cmd->pool, arg);
            break;
        case E_FailureURL:
            sconf->failure_url = apr_pstrdup(cmd->pool, arg);
            break;
        case E_Keyring:
            sconf->keyring_path = ap_server_root_relative(cmd->pool, arg);
            break;
        case E_Keytab:
            sconf->keytab_path = ap_server_root_relative(cmd->pool, arg);
            break;
        case E_ServiceTokenCache:
            sconf->st_cache_path = ap_server_root_relative(cmd->pool, arg);
            break;
        case E_VarPrefix:
            sconf->var_prefix = apr_pstrdup(cmd->pool, arg);
            break;
            /* start of dconfigs */
        case E_SubjectAuthType:
            dconf->subject_auth_type = apr_pstrdup(cmd->pool, arg);
            break;
        case E_ReturnURL:
            dconf->return_url = apr_pstrdup(cmd->pool, arg);
            break;
        default:
            error_str = 
                apr_psprintf(cmd->pool,
                             "Invalid value cmd->info(%d) for directive %s",
                             e,
                             cmd->directive->directive);
            break;

    }
    return error_str;
}


static const char *
cfg_flag(cmd_parms *cmd, void *mconfig, int flag)
{
    int e = (int)cmd->info;
    char *error_str = NULL;
    MWA_DCONF *dconf = (MWA_DCONF*) mconfig;

    MWA_SCONF *sconf = (MWA_SCONF *)
        ap_get_module_config(cmd->server->module_config, &webauth_module);
    
    switch (e) {
        /* server configs */
        case E_SecureCookie:
            sconf->secure_cookie = flag;
            sconf->secure_cookie_ex = 1;
            break;
        case E_Debug:
            sconf->debug = flag;
            break;
            /* start of dconfigs */
        case E_ForceLogin:
            dconf->force_login = flag;
            break;
        default:
            error_str = 
                apr_psprintf(cmd->pool,
                             "Invalid value cmd->info(%d) for directive %s",
                             e,
                             cmd->directive->directive);
            break;

    }
    return error_str;
}

static const char *
cfg_int(cmd_parms *cmd, void *mconf, const char *arg)
{
    int e = (int)cmd->info;
    char *endptr;
    char *error_str = NULL;
    MWA_DCONF *dconf = (MWA_DCONF*) mconf;

    MWA_SCONF *sconf = (MWA_SCONF *)
        ap_get_module_config(cmd->server->module_config, &webauth_module);

    int val = (int) strtol(arg, &endptr, 10);

    if ((*arg == '\0') || (*endptr != '\0')) {
        error_str = apr_psprintf(cmd->pool,
                     "Invalid value for directive %s, expected integer",
                     cmd->directive->directive);
    } else {
        switch (e) {
            case E_AppTokenLifetime:
                dconf->app_token_lifetime = val*60; /*convert from minutes */
                break;
            case E_TokenMaxTTL:
                sconf->token_max_ttl = val*60; /* convert from minutes */
                break;
            case E_InactiveExpire:
                dconf->inactive_expire = val*60; /* convert from minutes */
                break;
            default:
                error_str = 
                    apr_psprintf(cmd->pool,
                                "Invalid value cmd->info(%d) for directive %s",
                                 e,
                                 cmd->directive->directive);
                break;
        }
    }
    return error_str;
}


#define SSTR(dir,mconfig,help) \
  {dir, (cmd_func)cfg_str,(void*)mconfig, RSRC_CONF, TAKE1, help}

#define SFLAG(dir,mconfig,help) \
  {dir, (cmd_func)cfg_flag,(void*)mconfig, RSRC_CONF, FLAG, help}

#define SINT(dir,mconfig,help) \
  {dir, (cmd_func)cfg_int, (void*)mconfig, RSRC_CONF, TAKE1, help}

#define DSTR(dir,mconfig,help) \
  {dir, (cmd_func)cfg_str,(void*)mconfig, OR_AUTHCFG, TAKE1, help}

#define DFLAG(dir,mconfig,help) \
  {dir, (cmd_func)cfg_flag,(void*)mconfig, OR_AUTHCFG, FLAG, help}

#define DINT(dir,mconfig,help) \
  {dir, (cmd_func)cfg_int, (void*)mconfig, OR_AUTHCFG, TAKE1, help}

static const command_rec cmds[] = {
    /* server/vhost */
    SSTR(CD_WebKDCURL, E_WebKDCURL, CM_WebKDCURL),
    SSTR(CD_WebKDCPrincipal, E_WebKDCPrincipal, CM_WebKDCPrincipal),
    SSTR(CD_LoginURL, E_LoginURL, CM_LoginURL),
    SSTR(CD_FailureURL, E_FailureURL, CM_FailureURL),
    SSTR(CD_Keyring, E_Keyring, CM_Keyring),
    SSTR(CD_Keytab, E_Keytab,  CM_Keytab),
    SSTR(CD_ServiceTokenCache, E_ServiceTokenCache, CM_ServiceTokenCache),
    SSTR(CD_VarPrefix, E_VarPrefix, CM_VarPrefix),
    SFLAG(CD_Debug, E_Debug, CM_Debug),
    SFLAG(CD_SecureCookie, E_SecureCookie, CM_SecureCookie),
    SINT(CD_TokenMaxTTL, E_TokenMaxTTL, CM_TokenMaxTTL),

    /* directory */
    DINT(CD_AppTokenLifetime, E_AppTokenLifetime, CM_AppTokenLifetime),
    DSTR(CD_SubjectAuthType, E_SubjectAuthType, CM_SubjectAuthType),
    DINT(CD_InactiveExpire, E_InactiveExpire, CM_InactiveExpire),
    DFLAG(CD_ForceLogin, E_ForceLogin, CM_ForceLogin),
    DSTR(CD_ReturnURL, E_ReturnURL, CM_ReturnURL),

    { NULL }
};

#undef SSTR
#undef SFLAG
#undef SINT
#undef DSTR
#undef DFLAG
#undef DINT

static void 
register_hooks(apr_pool_t *p)
{
    /* get our module called before the basic authentication stuff */
    static const char * const mods[]={ "mod_access.c", "mod_auth.c", NULL };

    ap_hook_post_config(mod_webauth_init, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_child_init(mod_webauth_child_init, NULL, NULL, APR_HOOK_MIDDLE);

    /* we need to get run before anyone else, so we can clean up the URL
       if need be */
    ap_hook_translate_name(translate_name_hook, NULL, NULL, 
                           APR_HOOK_REALLY_FIRST);

    ap_hook_check_user_id(check_user_id_hook, NULL, mods, APR_HOOK_MIDDLE);
    //ap_hook_auth_checker(webauth_auth_checker, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_handler(handler_hook, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_fixups(fixups_hook, NULL,NULL,APR_HOOK_MIDDLE);
}

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA webauth_module = {
    STANDARD20_MODULE_STUFF, 
    config_dir_create,     /* create per-dir    config structures */
    config_dir_merge,      /* merge  per-dir    config structures */
    config_server_create,  /* create per-server config structures */
    config_server_merge,   /* merge  per-server config structures */
    cmds,                  /* table of config file commands       */
    register_hooks         /* register hooks                      */
};

