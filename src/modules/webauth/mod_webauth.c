/* 
**  mod_webauth.c -- Apache sample webauth module
**  [Autogenerated via ``apxs -n webauth -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory 
**  by running:
**
**    $ apxs -c -i mod_webauth.c
**
**  Then activate it in Apache's httpd.conf file for instance
**  for the URL /webauth in as follows:
**
**    #   httpd.conf
**    LoadModule webauth_module modules/mod_webauth.so
**    <Location /webauth>
**    SetHandler webauth
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /webauth and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/webauth 
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 OK
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**  
**    The sample page from mod_webauth.c
*/ 

#include "httpd.h"
#include "http_config.h"
#include "http_log.h"
#include "http_protocol.h"
#include "ap_config.h"
#include "apr.h"
#include "apr_lib.h"
#include "apr_strings.h"

module webauth_module;

typedef struct {
    char *webkdc_url;
    char *login_url;
    char *failure_url;
    char *keyring_path;
    char *keytab_path;
    char *st_cache_path;
    char *var_prefix;
    int  debug;
} WEBAUTH_SCONF;


typedef struct {
    int app_token_lifetime;
    int token_max_ttl;
    char *subject_auth_type;
    int inactive_expire;
    int hard_expire;
    int force_login;
    char *return_url;
} WEBAUTH_DCONF;

/*
**
**  per-server configuration structure handling
**
*/

static void *config_server_create(apr_pool_t *p, server_rec *s)
{
    WEBAUTH_SCONF *sconf;

    sconf = (WEBAUTH_SCONF*)apr_pcalloc(p, sizeof(WEBAUTH_SCONF));
    /* no defaults */
    return (void *)sconf;
}

static void *config_dir_create(apr_pool_t *p, char *path)
{
    WEBAUTH_DCONF *dconf;
    dconf = (WEBAUTH_DCONF*)apr_pcalloc(p, sizeof(WEBAUTH_DCONF));
    /* no defaults */
    return (void *)dconf;
}


#define SET_STR(field) \
    conf->field = (oconf->field != NULL) ? oconf->field : bconf->field

#define SET_INT(field) \
    conf->field = oconf->field ? oconf->field : bconf->field

static void *config_server_merge(apr_pool_t *p, void *basev, void *overv)
{
    WEBAUTH_SCONF *conf, *bconf, *oconf;

    conf = (WEBAUTH_SCONF*) apr_pcalloc(p, sizeof(WEBAUTH_SCONF));
    bconf = (WEBAUTH_SCONF*) basev;
    oconf = (WEBAUTH_SCONF*) overv;

    SET_STR(webkdc_url);
    SET_STR(login_url);
    SET_STR(failure_url);
    SET_STR(keyring_path);
    SET_STR(keytab_path);
    SET_STR(st_cache_path);
    SET_STR(var_prefix);
    SET_INT(debug);
    return (void *)conf;
}

static void *config_dir_merge(apr_pool_t *p, void *basev, void *overv)
{
    WEBAUTH_DCONF *conf, *bconf, *oconf;

    conf = (WEBAUTH_DCONF*) apr_pcalloc(p, sizeof(WEBAUTH_DCONF));
    bconf = (WEBAUTH_DCONF*) basev;
    oconf = (WEBAUTH_DCONF*) overv;

    SET_INT(app_token_lifetime);
    SET_INT(token_max_ttl);
    SET_STR(subject_auth_type);
    SET_INT(inactive_expire);
    SET_INT(hard_expire);
    SET_INT(force_login);
    SET_STR(return_url);
    return (void *)conf;
}

#undef SET_STR
#undef SET_INT

/* The sample content handler */
static int 
webauth_handler(request_rec *r)
{
    if (strcmp(r->handler, "webauth")) {
        return DECLINED;
    }
    r->content_type = "text/html";      

    if (!r->header_only)
        ap_rputs("The sample page from mod_webauth.c\n", r);
    return OK;
}

static int 
webauth_check_user_id(request_rec *r)
{
    return DECLINED;
}

static int 
webauth_auth_checker(request_rec *r)
{
    return DECLINED;
}

/*
 *  need to munge the following and remove passed token:
 *    r->the_request
 *    r->unparsed_uri
 *    r->args
 *    r->parsed_uri.query
 *
 *  we'll stick the token in the notes table for the initial
 *  request
 *  
 */
static int 
webauth_translate_name(request_rec *r)
{
    char *p;
    char *t = ";;GOO=";

    /* only need to check for tokens on the initial requeste */
    if (!ap_is_initial_req(r)) {
        return DECLINED;
    }

    if (r->the_request != NULL) {
        p = ap_strstr(r->the_request, t);
        if (p != NULL) {
            char *d = p;
            int past_goo=0;
            p += 6;
            while (*p) {
                if (!past_goo && (*p == ';' && *(p+1) == ';')) {
                    p+=2;
                    past_goo = 1;
                }
                if (past_goo) {
                    *d++ = *p;
                }
                p++;
            }
            *d = '\0';
        }
    }

    if (r->unparsed_uri != NULL) {
        p = ap_strstr(r->unparsed_uri, t);
        if (p != NULL)
            *p = '\0';
    }

    if (r->args != NULL) {
        p = ap_strstr(r->args, t);
        if (p != NULL)
            *p = '\0';
    }

    if (r->parsed_uri.query != NULL) {
        p = ap_strstr(r->parsed_uri.query, t);
        if (p != NULL)
            *p = '\0';
    }
}

static int 
webauth_fixups(request_rec *r)
{
    if (ap_is_initial_req(r)) {
        char *new_cookie;

        /*new_cookie = apr_psprintf(r->pool, "MOD_WEBAUTH=%d; path=/",
                                  apr_time_now());
        apr_table_setn(r->headers_out, "Set-Cookie", new_cookie);
        */
#define DOIT(a,b) ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, \
              "mod_webauth got invoked! %s(%s)", a, (b != NULL)? b:"(null)");
#define DOITD(a,b) ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, \
              "mod_webauth got invoked! %s(%d)", a, b);

        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "-------------- raw ------------------");

        DOIT("the_request", r->the_request);
        DOIT("unparsed_uri", r->unparsed_uri);
        DOIT("uri", r->uri);
        DOIT("filename", r->filename);
        DOIT("canonical_filename", r->canonical_filename);
        DOIT("path_info", r->path_info);
        DOIT("args", r->args);
        DOITD("rpu->is_initialized", r->parsed_uri.is_initialized);
        DOIT("rpu->query", r->parsed_uri.query);

        //strip_tokens(r);

        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "-------------- stripped ------------------");

        DOIT("unparsed_uri", r->unparsed_uri);
        DOIT("uri", r->uri);
        DOIT("filename", r->filename);
        DOIT("canonical_filename", r->canonical_filename);
        DOIT("path_info", r->path_info);
        DOIT("args", r->args);
        DOITD("rpu->is_initialized", r->parsed_uri.is_initialized);
        DOIT("rpu->query", r->parsed_uri.query);
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "--------------------------------");

    } else {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, 
                     "mod_webauth subreq got invoked! url(%s)", r->unparsed_uri);
    }
    return DECLINED;
}

static void 
webauth_register_hooks(apr_pool_t *p)
{
  /* our module needs to be called before the basic authentication stuff */
  static const char * const mods[]={ "mod_access.c", "mod_auth.c", NULL };

    /* unclear if we have to use APR_HOOK_FIRST or not for translate_name */
    ap_hook_translate_name(webauth_translate_name, NULL, NULL, APR_HOOK_FIRST);

    ap_hook_check_user_id(webauth_check_user_id, NULL, mods, APR_HOOK_MIDDLE);
    ap_hook_auth_checker(webauth_auth_checker, NULL, mods, APR_HOOK_MIDDLE);

    ap_hook_handler(webauth_handler, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_fixups(webauth_fixups,NULL,NULL,APR_HOOK_MIDDLE);
}

enum {
    E_WebKDCURL,
    E_LoginURL,
    E_FailureURL,
    E_Keyring,
    E_Keytab,
    E_ServiceTokenCache,
    E_VarPrefix,
    E_Debug,
    E_AppTokenLifetime,
    E_TokenMaxTTL,
    E_SubjectAuthType,
    E_InactiveExpire,
    E_HardExpire,
    E_ForceLogin,
    E_ReturnURL
};

static const char *
cfg_str(cmd_parms *cmd, void *mconf, const char *arg)
{
    int e = (int)cmd->info;
    char *error_str = NULL;
    WEBAUTH_DCONF *dconf = (WEBAUTH_DCONF *)mconf;

    WEBAUTH_SCONF *sconf = (WEBAUTH_SCONF *)
        ap_get_module_config(cmd->server->module_config, &webauth_module);
    
    char *value = apr_pstrdup(cmd->pool, arg);

    switch (e) {
        /* server configs */
        case E_WebKDCURL:
            sconf->webkdc_url = value;
            break;
        case E_LoginURL:
            sconf->login_url = value;
            break;
        case E_FailureURL:
            sconf->failure_url = value;
            break;
        case E_Keyring:
            sconf->keyring_path = value;
            break;
        case E_Keytab:
            sconf->keytab_path = value;
            break;
        case E_ServiceTokenCache:
            sconf->st_cache_path = value;
            break;
        case E_VarPrefix:
            sconf->var_prefix = value;
            break;
            /* start of dconfigs */
        case E_SubjectAuthType:
            dconf->subject_auth_type = value;
            break;
        case E_ReturnURL:
            dconf->return_url = value;
            break;
        default:
            error_str = 
                apr_psprintf(cmd->pool,
                             "Invalid value cmd->info(%d) for directive %s",
                             e,
                             cmd->directive->directive);
            break;

    }
    return error_str;
}


static const char *
cfg_flag(cmd_parms *cmd, void *mconfig, int flag)
{
    int e = (int)cmd->info;
    char *error_str = NULL;
    WEBAUTH_DCONF *dconf = (WEBAUTH_DCONF*) mconfig;

    WEBAUTH_SCONF *sconf = (WEBAUTH_SCONF *)
        ap_get_module_config(cmd->server->module_config, &webauth_module);
    
    switch (e) {
        /* server configs */
        case E_Debug:
            sconf->debug = flag;
            break;
            /* start of dconfigs */
        case E_ForceLogin:
            dconf->force_login = flag;
            break;
        default:
            error_str = 
                apr_psprintf(cmd->pool,
                             "Invalid value cmd->info(%d) for directive %s",
                             e,
                             cmd->directive->directive);
            break;

    }
    return error_str;
}

static const char *
cfg_int(cmd_parms *cmd, void *mconf, const char *arg)
{
    int e = (int)cmd->info;
    char *endptr;
    char *error_str = NULL;
    WEBAUTH_DCONF *dconf = (WEBAUTH_DCONF*) mconf;

    int val = (int) strtol(arg, &endptr, 10);

    if ((*arg == '\0') || (*endptr != '\0')) {
        error_str = apr_psprintf(cmd->pool,
                     "Invalid value for directive %s, expected integer",
                     cmd->directive->directive);
    } else {
        switch (e) {
            /* start of dconfigs */
            case E_AppTokenLifetime:
                dconf->app_token_lifetime = val;
                break;
            case E_TokenMaxTTL:
                dconf->token_max_ttl = val;
                break;
            case E_InactiveExpire:
                dconf->inactive_expire = val;
                break;
            case E_HardExpire:
                dconf->hard_expire = val;
                break;
            default:
                error_str = 
                    apr_psprintf(cmd->pool,
                                "Invalid value cmd->info(%d) for directive %s",
                                 e,
                                 cmd->directive->directive);
                break;
        }
    }
    return error_str;
}


#define SSTR(dir,mconfig,help) \
  {"WebAuth" dir, (cmd_func)cfg_str,(void*)mconfig, RSRC_CONF, TAKE1, help}

#define SFLAG(dir,mconfig,help) \
  {"WebAuth" dir, (cmd_func)cfg_flag,(void*)mconfig, RSRC_CONF, FLAG, help}

#define SINT(dir,mconfig,help) \
  {"WebAuth" dir, (cmd_func)cfg_int, (void*)mconfig, RSRC_CONF, TAKE1, help}

#define DSTR(dir,mconfig,help) \
{"WebAuth" dir, (cmd_func)cfg_str,(void*)mconfig, OR_AUTHCFG, TAKE1, help}

#define DFLAG(dir,mconfig,help) \
  {"WebAuth" dir, (cmd_func)cfg_flag,(void*)mconfig, OR_AUTHCFG, FLAG, help}

#define DINT(dir,mconfig,help) \
  {"WebAuth" dir, (cmd_func)cfg_int, (void*)mconfig, OR_AUTHCFG, TAKE1, help}

static const command_rec webauth_cmds[] = {
    /* server/vhost */
    SSTR("WebKDCURL", E_WebKDCURL, "URL for the WebKDC XML service"),
    SSTR("LoginURL", E_LoginURL, "URL for the login page"),
    SSTR("LoginURL", E_LoginURL, "URL for the login page"),
    SSTR("FailureURL", E_FailureURL, "URL for serious webauth failures"),
    SSTR("Keyring", E_Keyring, "path to the keyring file"),
    SSTR("Keytab", E_Keytab,  "path to the K5 keytab file"),
    SSTR("ServiceTokenCache", E_ServiceTokenCache, 
         "path to the service token cache file"),
    SSTR("VarPrefix", E_VarPrefix, "prefix to prepend to env variables"),
    SFLAG("Debug", E_Debug, "turn debugging on or off"),

    /* directory */

    DINT("AppTokenLifetime", E_AppTokenLifetime, "lifetime of app-tokens"),
    DINT("TokenMaxTTL", E_TokenMaxTTL, 
         "max ttl of tokens that are supposed to be \"recent\""),
    DSTR("SubectAuthType", E_SubjectAuthType, 
         "type of subject authenticator returned in id-token"),
    DINT("InactiveExpire", E_InactiveExpire,
         "duration of inactivity before an app-token expires"),
    DINT("HardExpire", E_HardExpire, 
         "tokens older then this (or their expiration time) will be treated as expired"),
    DFLAG("ForceLogin", E_ForceLogin, 
         "having no valid app-token forces a username/password prompt"),
    DSTR("ReturnURL", E_ReturnURL, "url to return to after logging in"),
};

#undef SSTR
#undef SFLAG
#undef SINT
#undef DSTR
#undef DFLAG
#undef DINT

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA webauth_module = {
    STANDARD20_MODULE_STUFF, 
    config_dir_create,     /* create per-dir    config structures */
    config_dir_merge,      /* merge  per-dir    config structures */
    config_server_create,  /* create per-server config structures */
    config_server_merge,   /* merge  per-server config structures */
    webauth_cmds,          /* table of config file commands       */
    webauth_register_hooks /* register hooks                      */
};

