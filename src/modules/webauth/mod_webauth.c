/* 
**  mod_webauth.c -- Apache sample webauth module
**  [Autogenerated via ``apxs -n webauth -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory 
**  by running:
**
**    $ apxs -c -i mod_webauth.c
**
**  Then activate it in Apache's httpd.conf file for instance
**  for the URL /webauth in as follows:
**
**    #   httpd.conf
**    LoadModule webauth_module modules/mod_webauth.so
**    <Location /webauth>
**    SetHandler webauth
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /webauth and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/webauth 
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 OK
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**  
**    The sample page from mod_webauth.c
*/ 

#include "mod_webauth.h"

/*
 * get note from main request 
 */
const char *
get_note(request_rec *r, const char *note)
{
    if (r->main) {
        return apr_table_get(r->main->notes, note);
    } else {
        return apr_table_get(r->notes, note);
    }
}

/*
 * remove note from main request, and return it if it was set, or NULL
 * if unset
 */
char *
remove_note(request_rec *r, const char *note)
{
    const char *val;
    if (r->main)
        r = r->main;

    val = apr_table_get(r->notes, note);

    if (val != NULL)
        apr_table_unset(r->notes, note);

    return (char*)val;
}

/*
 * set note to main request. does not make copy of data
 */
setn_note(request_rec *r, const char *note, const char *val)
{
    if (r->main) {
        apr_table_setn(r->main->notes, note, val);
    } else {
        apr_table_setn(r->notes, note, val);
    }
}


/*
 * log interesting stuff from the request
 */
static void 
log_request(request_rec *r, const char *msg)
{

    /* FIXME: disabling for now */
    return;

#define LOG_S(a,b) ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, \
              "mod_webauth: %s(%s)", a, (b != NULL)? b:"(null)");
#define LOG_D(a,b) ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, \
              "mod_webauth: %s(%d)", a, b);

    ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                 "mod_webauth: -------------- %s ------------------", msg);

    LOG_S("ap_auth_type", ap_auth_type(r));
    LOG_S("the_request", r->the_request);
    LOG_S("unparsed_uri", r->unparsed_uri);
    LOG_S("uri", r->uri);
    LOG_S("filename", r->filename);
    LOG_S("canonical_filename", r->canonical_filename);
    LOG_S("path_info", r->path_info);
    LOG_S("args", r->args);
    LOG_D("rpu->is_initialized", r->parsed_uri.is_initialized);
    LOG_S("rpu->query", r->parsed_uri.query);

    ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                 "mod_webauth: -------------- %s ------------------", msg);

#undef LOG_S
#undef LOG_D
}

static int 
die(const char *message, server_rec *s)
{
    if (s) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
                     "mod_webauth: fatal error: %s", message);
    }
    printf("mod_webauth: fatal error: %s\n", message);
    exit(1);
}


/*
 * module cleanup
 */
apr_status_t
mod_webauth_cleanup(void *data)
{
    MWA_SCONF *sconf = (MWA_SCONF*) data;

    if (sconf->ctxt == NULL)
        return APR_SUCCESS;

    if (sconf->ctxt->ring != NULL) {
        webauth_keyring_free(sconf->ctxt->ring);
    }
    return APR_SUCCESS;
}

/*
 * called after config has been loaded in parent process
 */
static int
mod_webauth_init(apr_pool_t *pconf, apr_pool_t *plog,
                 apr_pool_t *ptemp, server_rec *s)
{
    MWA_SCONF *sconf;
    MWA_SCTXT *sctxt;
    int status;

    sconf = (MWA_SCONF*)ap_get_module_config(s->module_config,
                                                 &webauth_module);

    ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, "mod_webauth: initializing");

#define CHECK_DIR(field,dir) if (sconf->field == NULL) \
             die(apr_psprintf(ptemp, "directive %s must be set", dir), s)

    CHECK_DIR(login_url, CD_LoginURL);
    CHECK_DIR(keyring_path, CD_Keyring);
#undef CHECK_DIR

    /* register pool cleanup function */
    apr_pool_cleanup_register(pconf, sconf, mod_webauth_cleanup, 
                              apr_pool_cleanup_null);


    sctxt = (MWA_SCTXT *) apr_palloc(pconf, sizeof(MWA_SCTXT));

    /* attempt to open up keyring */
    status = webauth_keyring_read_file(sconf->keyring_path, &sctxt->ring);
    if (status != WA_ERR_NONE) {
        die(apr_psprintf(ptemp, 
                 "mod_webauth: webauth_keyring_read_file(%s) failed: %s (%d)",
                         sconf->keyring_path, webauth_error_message(status), 
                         status), s);
    } else {
        /* FIXME: should probably make sure we have at least one
           valid (not expired/postdated) key in the ring */
    }

    /* stash the sctxt in the server's process pool */
    apr_pool_userdata_set(sctxt, "MWA_SCTXT", 
                          apr_pool_cleanup_null, s->process->pool);

    ap_add_version_component(pconf, WEBAUTH_VERSION);

    ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, "mod_webauth: initialized");

    return OK;
}

/*
 * called once per-child
 */
static void
mod_webauth_child_init(apr_pool_t *p, server_rec *s)
{
    /*
      MWA_SCONF *sconf;

      sconf = (MWA_SCONF*)ap_get_module_config(s->module_config,
      &webauth_module);

     ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, "mod_webauth: child_init_hook");
    */
}

/*
**
**  per-server configuration structure handling
**
*/

static void *
config_server_create(apr_pool_t *p, server_rec *s)
{
    MWA_SCONF *sconf;

    sconf = (MWA_SCONF*)apr_pcalloc(p, sizeof(MWA_SCONF));
    /* only one with a default */
    sconf->secure_cookie = 1;
    /* grab server context too */
    apr_pool_userdata_get((void*)&sconf->ctxt, "MWA_SCTXT", s->process->pool);
    return (void *)sconf;
}

static void *
config_dir_create(apr_pool_t *p, char *path)
{
    MWA_DCONF *dconf;
    dconf = (MWA_DCONF*)apr_pcalloc(p, sizeof(MWA_DCONF));
    /* no defaults */
    return (void *)dconf;
}


#define SET_PTR(field) \
    conf->field = (oconf->field != NULL) ? oconf->field : bconf->field

#define SET_INT(field) \
    conf->field = oconf->field ? oconf->field : bconf->field

static void *
config_server_merge(apr_pool_t *p, void *basev, void *overv)
{
    MWA_SCONF *conf, *bconf, *oconf;

    conf = (MWA_SCONF*) apr_pcalloc(p, sizeof(MWA_SCONF));
    bconf = (MWA_SCONF*) basev;
    oconf = (MWA_SCONF*) overv;

    /* secure_cookie is 1 by default, so we need to check if
       it was explicitly set in the override */
    if (oconf->secure_cookie_ex) {
        conf ->secure_cookie = oconf->secure_cookie;
    } else {
        conf ->secure_cookie = bconf->secure_cookie;
    }

    SET_PTR(webkdc_url);
    SET_PTR(login_url);
    SET_PTR(failure_url);
    SET_PTR(keyring_path);
    SET_PTR(keytab_path);
    SET_PTR(st_cache_path);
    SET_PTR(var_prefix);
    SET_INT(debug);
    SET_PTR(ctxt);
    return (void *)conf;
}

static void *
config_dir_merge(apr_pool_t *p, void *basev, void *overv)
{
    MWA_DCONF *conf, *bconf, *oconf;

    conf = (MWA_DCONF*) apr_pcalloc(p, sizeof(MWA_DCONF));
    bconf = (MWA_DCONF*) basev;
    oconf = (MWA_DCONF*) overv;

    SET_INT(app_token_lifetime);
    SET_INT(token_max_ttl);
    SET_PTR(subject_auth_type);
    SET_INT(inactive_expire);
    SET_INT(hard_expire);
    SET_INT(force_login);
    SET_PTR(return_url);
    return (void *)conf;
}

#undef SET_PTR
#undef SET_INT

/* The sample content handler */
static int 
handler_hook(request_rec *r)
{
    if (strcmp(r->handler, "webauth")) {
        return DECLINED;
    }
    r->content_type = "text/html";      

    if (!r->header_only)
        ap_rputs("The sample page from mod_webauth.c\n", r);
    return OK;
}

static WEBAUTH_ATTR_LIST *
parse_app_token(char *token,
                request_rec *r,
                MWA_SCONF *sconf, MWA_DCONF *dconf)
{
    WEBAUTH_ATTR_LIST *alist;
    int blen, status, i;

    ap_unescape_url(token);
    blen = apr_base64_decode_binary(token, token);

    /* parse the token, TTL is zero because app-tokens don't have ttl,
     * just expiration
     */
    status = webauth_token_parse(token, blen, 0, sconf->ctxt->ring, &alist);
    if (status != WA_ERR_NONE) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: webauth_token_parse failed: %s (%d)",
                     webauth_error_message(status), 
                     status);
        return NULL;
    }

    /* make sure its an app-token */
    status = webauth_attr_list_find(alist, WA_TK_TOKEN_TYPE, &i);
    if (i == -1) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                  "mod_webauth: check_cookie: can't find token type in token");
        return NULL;
    }

    if (strcmp((char*)alist->attrs[i].value, "app") != 0) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: check_cookie: token type(%s) not (app)",
                     (char*)alist->attrs[i].value);
        webauth_attr_list_free(alist);
        return NULL;
    }
    return alist;
}

/*
 * check cookie for valid app-token. If an epxired one is found,
 * do a Set-Cookie (in fixups) to blank it out.
 */
static char *
check_cookie(request_rec *r, MWA_SCONF *sconf, MWA_DCONF *dconf)
{
    const char *c;
    char *cs, *ce, *cval, *sub;
    int status, blen;
    int i;
    WEBAUTH_ATTR_LIST *alist;

    c = apr_table_get(r->headers_in, "Cookie");
    if (c == NULL) 
        return NULL;

    cs = ap_strstr(c, AT_COOKIE_NAME_EQ);
    if (cs == NULL) {
        return NULL;
    } else {
        cs += sizeof(AT_COOKIE_NAME_EQ)-1;
    }

    ce = ap_strchr(cs, ';');

    if (ce == NULL) {
        cval = apr_pstrdup(r->pool, cs);
    } else {
        cval = apr_pstrmemdup(r->pool, cs, ce-cs);
    }

    sub = NULL;

    alist = parse_app_token(cval, r, sconf, dconf);
    if (alist != NULL) {
        /* pull out subject */
        status = webauth_attr_list_find(alist, WA_TK_SUBJECT, &i);
        if (i != -1) {
            sub = apr_pstrdup(r->pool, (char*)alist->attrs[i].value);
        } else {
            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, 
                     "mod_webauth: check_cookie: can't find subject in token");
        }
        webauth_attr_list_free(alist);
    }

    if (sub == NULL) {
        /* we coudn't use the cookie, lets set it up to be nuked */
        char *cookie = apr_psprintf(r->pool,
                                    "%s=; path=/; expires=%s;%s",
                                    AT_COOKIE_NAME,
                                    "Thu, 26-Mar-1998 00:00:01 GMT",
                                    sconf->secure_cookie ? "secure" : "");
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: nuking cookie(%s): (%s)\n", 
                     AT_COOKIE_NAME, cookie);
        setn_note(r, N_APP_COOKIE, cookie);
        return NULL;
    }

    if (sub != NULL) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: found valid %s cookie for (%s)", 
                     AT_COOKIE_NAME,
                     sub);

    }
    return sub;
}

WEBAUTH_KEY *
get_session_key(char *token,
                request_rec *r,
                MWA_SCONF *sconf,
                MWA_DCONF *dconf)
{
    WEBAUTH_ATTR_LIST *alist;
    WEBAUTH_KEY *key;
    int status, i;

    alist = parse_app_token(token, r, sconf, dconf);

    if (alist == NULL)
        return NULL;

    /* pull out session key */
    status = webauth_attr_list_find(alist, WA_TK_SESSION_KEY, &i);
    if (i == -1) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, 
                    "mod_webauth: check_url: can't find session key in token");
        webauth_attr_list_free(alist);
        return NULL;
    }

    key = webauth_key_create(WA_AES_KEY,
                             (unsigned char*)alist->attrs[i].value,
                             alist->attrs[i].length);
    webauth_attr_list_free(alist);
    if (key == NULL) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
           "mod_webauth: check_url: can't find session key in WEBAUTHS token");
    }
    return key;
}

char *
parse_returned_token(char *token,
                     WEBAUTH_KEY *key,
                     request_rec *r, 
                     MWA_SCONF *sconf, 
                     MWA_DCONF *dconf)
{
    /* if we successfully parse an id-token, write out new webauth_at cookie */
    return NULL;
}

/*
 * check to see if we got passed WEBAUTHR and WEBAUTHS
 */
static char *
check_url(request_rec *r, MWA_SCONF *sconf, MWA_DCONF *dconf)
{
    char *subject, *wr, *ws;
    WEBAUTH_KEY *key = NULL;

    wr = remove_note(r, N_WEBAUTHR);
    if (wr == NULL) {
        return NULL;
    }

    ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                 "mod_webauth: check_url: found wr(%s)", wr);

    /* see if we have WEBAUTHS, which has the session key to use */
    ws = remove_note(r, N_WEBAUTHS);

    if (ws != NULL) {
        key = get_session_key(ws, r, sconf, dconf);
        if (key == NULL)
            return NULL;
        subject = parse_returned_token(wr, key, r, sconf, dconf);
        webauth_key_free(key);
    } else {
        /* FIXME: use key from session-token */
        /* subject = parse_returned_token(wr, key, r, sconf, dconf); */
        subject = NULL;
    }
    return subject;
}

static int 
check_user_id_hook(request_rec *r)
{
    const char *at = ap_auth_type(r);
    const char *subject, *cookie;
    MWA_SCONF *sconf;
    MWA_DCONF *dconf;

    dconf = (MWA_DCONF*)ap_get_module_config(r->per_dir_config,
                                                 &webauth_module);

    sconf = (MWA_SCONF*)ap_get_module_config(r->server->module_config,
                                                 &webauth_module);

    ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                 "mod_webauth: in check_user_id hook");

    if ((at == NULL) || (strcmp(at, "WebAuth") != 0)) {
        return DECLINED;
    }

    /* first check if we've already validated the user */
    subject = get_note(r, N_SUBJECT);

    if (subject == NULL) {
        /* next, check for valid app-token cookie */
        subject = check_cookie(r, sconf, dconf);

        if (subject == NULL) {
            /* if no valid app token, look for WEBAUTHR in url */
            subject = check_url(r, sconf, dconf);
        }
        /* stick it in note for future reference */
        if (subject != NULL)
            setn_note(r, N_SUBJECT, subject);
    }

    /* see if we have to update our cookie and save it in err_headers_out
     * so it always gets sent. check_cookie and check_url both will
     * set the N_APP_COOKIE note if they need a new cooke 
     */

    if (cookie = remove_note(r, N_APP_COOKIE))
        apr_table_addn(r->err_headers_out, "Set-Cookie", cookie);

    if (subject != NULL) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: check_user_id_hook setting user(%s)",
                     subject);
        r->user = (char*)subject;
        r->ap_auth_type = (char*)at;
        return OK;
    } else {
        /* we would normally redirect at this point */
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: check_user_id_hook: no valid user found");
        return HTTP_UNAUTHORIZED;
    }

    /* FIXME: would normally return DECLINED at this point */
    /* FIXME: hack test for redirect handling */
    if ((r->args != NULL) && (*(r->args) == 'Z')) {
    ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                 "mod_webauth: set Location, returning redirect...");
    apr_table_setn(r->err_headers_out, "Location", sconf->login_url);
        return HTTP_MOVED_TEMPORARILY;
    } else {
        return OK;
    }
}

static int 
auth_checker_hook(request_rec *r)
{
    return DECLINED;
}

static void
strip_end(char *c, char *t)
{
    char *p;
    if (c != NULL) {
        p = ap_strstr(c, t);
        if (p != NULL)
            *p = '\0';
    }
}

/*
 * this hook will attempt to find the returned-token and the
 * state-token in the URL. If we find them and stash them in 
 * the notes for the master request, and then remove them from 
 * everywhere we find them, including the r->the_request, so they 
 * don't show up in access_logs.
 *
 *  we check in the following places:
 *    r->the_request
 *    r->unparsed_uri
 *    r->uri
 *    r->filename
 *    r->canonical_filename
 *    r->path_info
 *    r->args
 *    r->parsed_uri.path
 *    r->parsed_uri.query
 *
 *  we'll stick the token in the notes table for the initial
 *  request
 *  
 */
static int 
translate_name_hook(request_rec *r)
{
    char *p, *s, *rp;
    char *wr, *ws;

    static char *rmagic = WEBAUTHR_MAGIC;
    static char *smagic = WEBAUTHS_MAGIC;

    ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, 
                 "mod_webauth: translate_name_hook disabled for now");
    return DECLINED;

    if (!ap_is_initial_req(r)) {
        return DECLINED;
    }

    log_request(r, "before xlate");

    rp = ap_strstr(r->the_request, rmagic);
    if (rp == NULL) {
        /* no tokens in the request, return */
        return DECLINED;
    }

    /* we need to save the tokens for check_user_id_hook. */

    s = rp+WEBAUTHR_MAGIC_LEN;
    p = ap_strchr(s, ';');
    if (p == NULL) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: didn't find end of %s", rmagic);
        return DECLINED;
    }
    wr = apr_pstrmemdup(r->pool, s, p-s);
    ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, 
                 "mod_webauth: stash wr(%s)", wr);
    setn_note(r, N_WEBAUTHR, wr);

    s = p+1;
    p = ap_strstr(s, smagic);
    if (p != NULL) {
        s = p+WEBAUTHS_MAGIC_LEN;
        p = ap_strchr(s, ';');
        if (p == NULL) {
            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                         "mod_webauth: didn't find end of %s", smagic);
            return DECLINED;
        }
        ws = apr_pstrmemdup(r->pool, s, p-s);
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "mod_webauth: stash ws(%s)", ws);
        setn_note(r, N_WEBAUTHS, ws);
        s = p+1;
    }
    /* move over remaining */
    strcpy(rp, s);
    
    /* these are easier, we strip rmagic and everything after it, 
       which might include smagic */

    strip_end(r->unparsed_uri, rmagic);
    strip_end(r->uri, rmagic);
    strip_end(r->filename, rmagic);
    strip_end(r->canonical_filename, rmagic);
    strip_end(r->path_info, rmagic);
    strip_end(r->args, rmagic);
    strip_end(r->parsed_uri.path, rmagic);
    strip_end(r->parsed_uri.query, rmagic);

    log_request(r, "after xlate");

    /* still need to return DECLINED, so other modules (like mod_rerewrite)
       get a crack at things */
    return DECLINED;
}

static int 
fixups_hook(request_rec *r)
{
    MWA_DCONF *dconf;
    MWA_SCONF *sconf;
    const char *subject;

    dconf = (MWA_DCONF*)ap_get_module_config(r->per_dir_config,
                                                 &webauth_module);

    sconf = (MWA_SCONF*)ap_get_module_config(r->server->module_config,
                                                 &webauth_module);

    if (ap_is_initial_req(r)) {
        char *new_cookie;
        const char *at;
        /*new_cookie = apr_psprintf(r->pool, "MOD_WEBAUTH=%d; path=/",
                                  apr_time_now());
        apr_table_setn(r->headers_out, "Set-Cookie", new_cookie);
        */

        log_request(r, "in fixups");
    } else {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, 
                     "mod_webauth: subreq fixups url(%s)", r->unparsed_uri);
    }

    /* set environment variable */
    subject = get_note(r, N_SUBJECT);
    if (subject) {
        char *name;
        if (sconf->var_prefix) {
            name = apr_pstrcat(r->pool, sconf->var_prefix, 
                               ENV_WEBAUTH_USER, NULL);
        } else {
            name = ENV_WEBAUTH_USER;
        }
        apr_table_setn(r->subprocess_env, name, subject);

    }
    return DECLINED;
}


static const char *
cfg_str(cmd_parms *cmd, void *mconf, const char *arg)
{
    int e = (int)cmd->info;
    char *error_str = NULL;
    MWA_DCONF *dconf = (MWA_DCONF *)mconf;

    MWA_SCONF *sconf = (MWA_SCONF *)
        ap_get_module_config(cmd->server->module_config, &webauth_module);
    
    switch (e) {
        /* server configs */
        case E_WebKDCURL:
            sconf->webkdc_url = apr_pstrdup(cmd->pool, arg);
            break;
        case E_LoginURL:
            sconf->login_url = apr_pstrdup(cmd->pool, arg);
            break;
        case E_FailureURL:
            sconf->failure_url = apr_pstrdup(cmd->pool, arg);
            break;
        case E_Keyring:
            sconf->keyring_path = ap_server_root_relative(cmd->pool, arg);
            break;
        case E_Keytab:
            sconf->keytab_path = ap_server_root_relative(cmd->pool, arg);
            break;
        case E_ServiceTokenCache:
            sconf->st_cache_path = ap_server_root_relative(cmd->pool, arg);
            break;
        case E_VarPrefix:
            sconf->var_prefix = apr_pstrdup(cmd->pool, arg);
            break;
            /* start of dconfigs */
        case E_SubjectAuthType:
            dconf->subject_auth_type = apr_pstrdup(cmd->pool, arg);
            break;
        case E_ReturnURL:
            dconf->return_url = apr_pstrdup(cmd->pool, arg);
            break;
        default:
            error_str = 
                apr_psprintf(cmd->pool,
                             "Invalid value cmd->info(%d) for directive %s",
                             e,
                             cmd->directive->directive);
            break;

    }
    return error_str;
}


static const char *
cfg_flag(cmd_parms *cmd, void *mconfig, int flag)
{
    int e = (int)cmd->info;
    char *error_str = NULL;
    MWA_DCONF *dconf = (MWA_DCONF*) mconfig;

    MWA_SCONF *sconf = (MWA_SCONF *)
        ap_get_module_config(cmd->server->module_config, &webauth_module);
    
    switch (e) {
        /* server configs */
        case E_SecureCookie:
            sconf->secure_cookie = flag;
            sconf->secure_cookie_ex = 1;
            break;
        case E_Debug:
            sconf->debug = flag;
            break;
            /* start of dconfigs */
        case E_ForceLogin:
            dconf->force_login = flag;
            break;
        default:
            error_str = 
                apr_psprintf(cmd->pool,
                             "Invalid value cmd->info(%d) for directive %s",
                             e,
                             cmd->directive->directive);
            break;

    }
    return error_str;
}

static const char *
cfg_int(cmd_parms *cmd, void *mconf, const char *arg)
{
    int e = (int)cmd->info;
    char *endptr;
    char *error_str = NULL;
    MWA_DCONF *dconf = (MWA_DCONF*) mconf;

    int val = (int) strtol(arg, &endptr, 10);

    if ((*arg == '\0') || (*endptr != '\0')) {
        error_str = apr_psprintf(cmd->pool,
                     "Invalid value for directive %s, expected integer",
                     cmd->directive->directive);
    } else {
        switch (e) {
            /* start of dconfigs */
            case E_AppTokenLifetime:
                dconf->app_token_lifetime = val*60; /*convert from minutes */
                break;
            case E_TokenMaxTTL:
                dconf->token_max_ttl = val*60; /* convert from minutes */
                break;
            case E_InactiveExpire:
                dconf->inactive_expire = val*60; /* convert from minutes */
                break;
            case E_HardExpire:
                dconf->hard_expire = val*60; /* convert from minutes */
                break;
            default:
                error_str = 
                    apr_psprintf(cmd->pool,
                                "Invalid value cmd->info(%d) for directive %s",
                                 e,
                                 cmd->directive->directive);
                break;
        }
    }
    return error_str;
}


#define SSTR(dir,mconfig,help) \
  {dir, (cmd_func)cfg_str,(void*)mconfig, RSRC_CONF, TAKE1, help}

#define SFLAG(dir,mconfig,help) \
  {dir, (cmd_func)cfg_flag,(void*)mconfig, RSRC_CONF, FLAG, help}

#define SINT(dir,mconfig,help) \
  {dir, (cmd_func)cfg_int, (void*)mconfig, RSRC_CONF, TAKE1, help}

#define DSTR(dir,mconfig,help) \
  {dir, (cmd_func)cfg_str,(void*)mconfig, OR_AUTHCFG, TAKE1, help}

#define DFLAG(dir,mconfig,help) \
  {dir, (cmd_func)cfg_flag,(void*)mconfig, OR_AUTHCFG, FLAG, help}

#define DINT(dir,mconfig,help) \
  {dir, (cmd_func)cfg_int, (void*)mconfig, OR_AUTHCFG, TAKE1, help}

static const command_rec cmds[] = {
    /* server/vhost */
    SSTR(CD_WebKDCURL, E_WebKDCURL, CM_WebKDCURL),
    SSTR(CD_LoginURL, E_LoginURL, CM_LoginURL),
    SSTR(CD_FailureURL, E_FailureURL, CM_FailureURL),
    SSTR(CD_Keyring, E_Keyring, CM_Keyring),
    SSTR(CD_Keytab, E_Keytab,  CM_Keytab),
    SSTR(CD_ServiceTokenCache, E_ServiceTokenCache, CM_ServiceTokenCache),
    SSTR(CD_VarPrefix, E_VarPrefix, CM_VarPrefix),
    SFLAG(CD_Debug, E_Debug, CM_Debug),
    SFLAG(CD_SecureCookie, E_SecureCookie, CM_SecureCookie),

    /* directory */
    DINT(CD_AppTokenLifetime, E_AppTokenLifetime, CM_AppTokenLifetime),
    DINT(CD_TokenMaxTTL, E_TokenMaxTTL, CM_TokenMaxTTL),
    DSTR(CD_SubjectAuthType, E_SubjectAuthType, CM_SubjectAuthType),
    DINT(CD_InactiveExpire, E_InactiveExpire, CM_InactiveExpire),
    DINT(CD_HardExpire, E_HardExpire, CM_HardExpire),
    DFLAG(CD_ForceLogin, E_ForceLogin, CM_ForceLogin),
    DSTR(CD_ReturnURL, E_ReturnURL, CM_ReturnURL),
    { NULL }
};

#undef SSTR
#undef SFLAG
#undef SINT
#undef DSTR
#undef DFLAG
#undef DINT

static void 
register_hooks(apr_pool_t *p)
{
    /* get our module called before the basic authentication stuff */
    static const char * const mods[]={ "mod_access.c", "mod_auth.c", NULL };

    ap_hook_post_config(mod_webauth_init, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_child_init(mod_webauth_child_init, NULL, NULL, APR_HOOK_MIDDLE);

    /* we need to get run before anyone else, so we can clean up the URL
       if need be */
    ap_hook_translate_name(translate_name_hook, NULL, NULL, 
                           APR_HOOK_REALLY_FIRST);

    ap_hook_check_user_id(check_user_id_hook, NULL, mods, APR_HOOK_MIDDLE);
    //ap_hook_auth_checker(webauth_auth_checker, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_handler(handler_hook, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_fixups(fixups_hook, NULL,NULL,APR_HOOK_MIDDLE);
}

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA webauth_module = {
    STANDARD20_MODULE_STUFF, 
    config_dir_create,     /* create per-dir    config structures */
    config_dir_merge,      /* merge  per-dir    config structures */
    config_server_create,  /* create per-server config structures */
    config_server_merge,   /* merge  per-server config structures */
    cmds,                  /* table of config file commands       */
    register_hooks         /* register hooks                      */
};

