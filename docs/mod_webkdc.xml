<?xml version="1.0"?>
<!DOCTYPE modulesynopsis SYSTEM "../style/modulesynopsis.dtd">
<?xml-stylesheet type="text/xsl" href="../style/manual.en.xsl"?>
<modulesynopsis metafile="mod_webkdc.xml.meta">

<name>mod_webkdc</name>
<description>WebAuth V3 WebKDC module</description>
<status>Contributed</status>
<sourcefile>mod_webkdc.c</sourcefile>
<identifier>webkdc_module</identifier>

<summary>

<p>This module implements the central authentication server for the
WebAuth V3 protocol, also known as the WebKDC.</p>

<p>The WebKDC authenticates the user based on information passed by the
weblogin service (which should generally run on the same system) and
generates authentication tokens both for the user's cookie cache to
support single sign-on and to send to application servers to authenticate
the user.  It is designed to store as little state as possible, using the
browser cookie cache as the repository for (encrypted) authentication
tokens and ticket caches.</p>

<p>Further details are provided in the
<a href="http://webauth.stanford.edu/">WebAuth documentation</a>.</p>

</summary>

<section><title>Setting up the WebKDC</title>

<p>The minimal configuration for the WebKDC requires two things: a keytab
for the Kerberos principal used by the WebKDC to authenticate requests
from application servers, and the <code>token.acl</code> file that
specifies what tokens application servers are permitted to request.</p>

<p>The keytab must be a Kerberos V5 keytab for the principal referenced in
the <directive>WebAuthWebKdcPrincipal</directive> configuration directive
on the application servers.  How to obtain a keytab will depend on one's
local Kerberos infrastructure; it may be via <code>kadmin</code> or via
some other local interface.</p>

<p>For information about the <code>token.acl</code> file, see the
<a href="#webkdctokenacl"><directive>WebKdcTokenAcl</directive></a>
documentation below.</p>

<p>Finally, the one piece of state that the WebKDC must maintain is its
local keyring, which holds the AES keys that it uses to encrypt and
decrypt tokens.  This keyring can either be generated and updated
automatically (the default) or managed externally using
<code>wa_keyring</code>.  See
<a href="#webkdckeyringautoupdate"><directive>WebKdcKeyringAutoUpdate</directive></a>
for more information.</p>

<p>The WebKDC must get a URL to itself on the host where it is running.
By convention, <code>/webkdc-service</code> is used.  This URL must be
only accessible via SSL, for security reasons.</p>

</section>

<section><title>Minimal Config File</title>

<p>The following example shows the minimum config file required to
configure and use <module>mod_webkdc</module>.</p>

<example><title>Example</title>
<pre>
LoadModule webkdc_module modules/mod_webkdc.so

WebKdcServiceTokenLifetime 30d
WebKdcKeyring conf/webkdc/keyring
WebKdcKeytab conf/webkdc/keytab
WebKdcTokenAcl conf/webkdc/token.acl

&lt;VirtualHost _default_:443>
  &lt;Location /webkdc-service>
     SetHandler webkdc
  &lt;/Location>
&lt;/VirtualHost>
</pre>
</example>

</section>

<section><title>WebKDC Logging</title>

<p>All commands received by the WebKDC and their results are logged to the
Apache error log with a log level of "notice".  These log messages always
begin with the string "mod_webkdc: event=&quot; followed by the event,
which is one of the following:</p>

<dl>
<dt>getTokens</dt>
<dd><p>A request for a service, id, proxy, or cred token.  You will see
    this action most frequently from WebAuth web servers acquiring new
    service tokens for use later when redirecting users to the WebLogin
    server and decoding the response.  When delegating user credentials to
    WebAuth application servers, those servers will send a
    <code>getTokens</code> request to the WebKDC to obtain those delegated
    credentials.</p>
</dd>

<dt>requestToken</dt>
<dd><p>A request for an id or proxy token for a user.  A proxy token for
    the WebKDC itself will also be returned for use with future requests
    by the same user.  This call will normally only be done by the
    WebLogin component of the WebKDC service; while the call is available
    to any client, clients wishing to bootstrap WebAuth cookies on their
    own should use the much simpler webkdcProxyToken call instead.</p>
</dd>

<dt>webkdcProxyToken</dt>
<dd><p>A request for a WebKDC proxy token (the token contained in the
    WebAuth single sign-on cookie) given a Kerberos authenticator.  This
    can be used by clients to bootstrap a WebAuth single sign-on cookie
    without having to visit the WebLogin server in a browser.</p>
</dd>

<dt>webkdcProxyTokenInfo</dt>
<dd><p>Given a WebKDC proxy token, returns various metadata about it, such
    as its expiration time.</p>
</dd>
</dl>

<p>Those who are familiar with the WebAuth protocol will recognize that
the four events logged are the four XML elements that the WebKDC protocol
permits.  (Other errors, such as unknown commands, are of course also
logged.)</p>

<p>Following the event will be additional key/value pairs in the form
key=value.  The possible keys are:</p>

<dl>
<dt>clientIp</dt>
<dd><p>Only for <code>requestToken</code> requests, this contains the
    client IP address as indicated by the WebLogin server.  If the
    WebLogin server didn't include the client IP address in the request,
    the value will be empty.  Please note that the WebKDC does not
    authenticate this information, only records whatever was passed in by
    the WebLogin server, which means that if <code>from</code> is not
    127.0.0.1 (meaning that the <code>requestToken</code> request didn't
    come from the WebLogin server), the value of this key should not be
    trusted.</p>
</dd>

<dt>errorCode</dt>
<dd><p>The error code for a protocol-level error.  The presence of this
    key means that some failure occurred in the course of parsing the XML
    document and therefore no action was taken in the WebKDC.</p>
</dd>

<dt>errorMessage</dt>
<dd><p>The error message corresponding to the error code from a
    <code>errorCode</code> key.</p>
</dd>

<dt>from</dt>
<dd><p>The IP address from which the request came.  For
    <code>requestToken</code> in the recommended configuration of running
    WebLogin servers on the same host as the WebKDC, this will normally
    always be 127.0.0.1, but will be more interesting for the other
    events.</p>
</dd>

<dt>lec</dt>
<dd><p>The login error code, only included for <code>requestToken</code>.
    If this is 0, the call was successful.  Otherwise, it contains the
    error code.</p>
</dd>

<dt>lem</dt>
<dd><p>If <code>lec</code> is non-zero in <code>requestToken</code>, this
    contains the error message corresponding to that error code.</p>
</dd>

<dt>ro</dt>
<dd><p>Any request options set by the WebAuth server.  The most common
    value here is "fa", indicating that the WebAuth server requested
    forced password authentication even if the user already had single
    sign-on credentials.  For more details on the possible values, see the
    WebAuth protocol specification.</p>
</dd>

<dt>rtt</dt>
<dd><p>The returned token type from a <code>requestToken</code> request.
    Normally this will be "id" for an id token, but may be another token
    type depending on what the WebAuth server asked for.</p>
</dd>

<dt>pt</dt>
<dd><p>For tokens of type <code>proxy</code>, this will contain the proxy
    token type.  Currently, the only supported proxy token type is
    <code>krb5</code>, which can be used by the WebAuth Application Server
    to request Kerberos v5 credentials on behalf of the user from the
    WebKDC.</p>
</dd>

<dt>sa</dt>
<dd><p>The requested subject authenticator type for a
    <code>requestToken</code> operation.  If the WebAuth Application Server
    requests an id token, this will indicate the type of id token it is
    requesting.  Possible values are <code>webkdc</code>, which provides
    the user's identity but no additional information, or
    <code>krb5</code>, which provides a Kerberos authenticator for the user
    that can be verified by the WebAuth Application Server's Kerberos
    key.</p>
</dd>

<dt>server</dt>
<dd><p>For <code>getTokens</code> and <code>requestToken</code>, this will
    contain the identifier of the requesting server (in the case of
    <code>requestToken</code>, this is the server that sent the user to
    WebLogin).</p>
</dd>

<dt>type</dt>
<dd><p>The type of token acquired by a <code>getTokens</code> call.</p>
</dd>

<dt>user</dt>
<dd><p>The user being authenticated.  This will normally be the username
    portion of a Kerberos identity, if it is known, for
    <code>requestToken</code>.  For protocol-level errors, it often will
    be unknown (because the protocol failed before the username was
    established) and will instead be the string "&lt;unknown&gt;".  For
    <code>getTokens</code>, it will be the user the tokens are for (the
    same as <code>server</code> in the most common case of acquiring
    service tokens).</p>
</dd>
</dl>

</section>

<section><title>Setting up Multiple WebKDCs</title>

<p>WebAuth V3 was designed so that it would be fairly easy to setup
multiple WebKDCs for load balancing and redundancy. There are three pieces
of information that need to be shared between WebKDC servers in order to
achieve this:</p>

<ol>
  <li>Token ACL file</li>
  <li>Kerberos keytab file</li>
  <li>WebKDC keyring file</li>
</ol>

<note><title>Note</title>
  <p>All the files should be securely transferred from the master to the
  slave or slaves using a program like <code>scp</code> that encrypts the
  file contents during the transfer.</p>
</note>

<p>By convention, one of the WebKDC's should be designated as the "master"
and other WebKDC's should be designated as "slaves."  These files should
only be updated on the master and pushed manually or automatically to the
slaves.</p>

<p>The token ACL file is specified using the
<a href="#webkdctokenacl"><directive>WebKdcTokenAcl</directive></a>
directive. This file should be maintained on the "master" WebKDC, and
copied to other WebKDCs.</p>

<p>The Kerberos keytab file is specified using the
<a href="$kwebkdckeytab"><directive>WebKdcKeytab</directive></a>
directive.  This is a standard Kerberos V5 keytab file containing the
principal used by WebAuth servers to initially communicate with the
WebKDC.  This is a binary file that should be kept consistent across all
the WebKDC servers.  Normally this means that you will need to download it
once and then copy it between systems, since Kerberos V5 generally changes
the key of a principal when downloading a new keytab for it.</p>

<p>The WebKDC keyring file is specified using the
<a href="#webkdckeyring"><directive>WebKdcKeyring</directive></a>
directive.  This file contains the WebKDCs private AES keys.  If you are
running multiple WebKDCs, you must turn off automatic updating of the
WebKDCs keyring file on restarts. This is done using the
<a href="#webkdckeyringautoupdate"><directive>WebKdcKeyringAutoUpdate</directive></a>
directive:</p>

<example><title>Turning off auto update</title>
WebKdcKeyringAutoUpdate off<br/>
</example>

<p>Once auto update is turned off, the keyring file will not be
automatically updated, and can be manually updated and then copied between
the servers.  The keys in the keyring file still need to be changed
periodically using the <code>wa_keyring</code> command.  This command
would be run on the keyring file on the master, and then the new keyring
should be copied to the slaves.  For example, to generate a new post-dated
key in the file called "keyring" you should do the following:</p>

<example><title>Generating a post-dated key</title>
wa_keyring -f ./keyring add 2d
</example>

<p>That example generates a new key that will be valid in seven days.  Any
existing keys in the keyring file are left as-is so outstanding tokens
continue to work.  The new keyring file can then safely be distributed to
the slave WebKDCs.   Then, the WebKDC must be restarted to pick up the new
key.</p>

<p>Old keys in the keyring file should also periodically be removed.  This
should be done using <code>wa_keyring</code> and the <code>gc</code>
command:</p>

<example><title>Automatically removing old keys</title>
<pre>
wa_keyring -f ./keyring gc -60d
</pre>
</example>

<p>This command would remove any key older than 90 days.  The time
interval that you pass to the <code>gc</code> command must be older than
the service token lifetime as specified with
<a href="#webkdcservicetokenlifetime"><directive>WebKdcServiceTokenLifetime</directive></a>.
The recommendation is to make it about twice as long.</p>

<p>To summarize, for each WebKDC (master and slaves), you'd want the
following directives:</p>

<example><title>Example</title>
<pre>
LoadModule webkdc_module modules/mod_webkdc.so

WebKdcServiceTokenLifetime 30d
WebKdcKeyring conf/webkdc/keyring
WebKdcKeytab conf/webkdc/keytab
WebKdcTokenAcl conf/webkdc/token.acl
WebKdcKeyringAutoUpdate off

&lt;VirtualHost _default_:443>
  &lt;Location /webkdc-service>
     SetHandler webkdc
  &lt;/Location>
&lt;/VirtualHost>
</pre>
</example>

<p>Periodically (once a month should be reasonable), you'd want to
generate a new key, remove old keys, and then update the keyring file on
the slaves using a script like this:</p>

<example><title>Monthly Key maintenance</title>
<pre>
wa_keyring -f conf/webkdc/keyring add 2d
wa_keyring -f conf/webkdc/keyring gc -60d
apache2ctl graceful
for host in slave1 slave2 ; do
    scp conf/webkdc/keyring $host:/path/to/conf/webkdc/keyring
    ssh $host apache2ctl graceful
done
</pre>
</example>

<p>If the servers are restarted regularly (such as for nightly log
rotation), you can omit the <code>apache2ctl graceful</code> restart and
just let that restart pick up the new keys.  The reason for post-dating
the key is to make sure that all of the servers pick it up before it
becomes valid and is used in service tokens.</p>

</section>

<directivesynopsis>
<name>WebkdcTokenMaxTTL</name>
<description>
  How old tokens may be before they're considered stale
</description>
<syntax>WebKdcTokenMaxTTL <em>nnnn[s|m|h|d|w]</em></syntax>
<default>WebKdcTokenMaxTTL 300s</default>
<contextlist>
  <context>server config</context>
  <context>virtual host</context>
</contextlist>

<usage>

<p>This directive sets how old tokens may be before they're considered
stale. It is used to help prevent tokens from being replayed and to ignore
old tokens in cookies, URLs, etc.  It is important to keep the clocks of
the web application servers and the WebKDC synchronized; if they aren't,
all tokens from that application server may be considered stale.</p>

<p>In practice, this setting will also double as a limit on how long a
user may take while logging in via weblogin.  If they take longer than
this TTL, the request token will have timed out by the time they
authenticate.</p>

<p>The units for the TTL are specified by appending a single letter.  This
letter may be one of <code>s</code>, <code>m</code>, <code>h</code>,
<code>d</code>, or <code>w</code>, which correspond to seconds, minutes,
hours, days, and weeks, respectively.</p>

<example><title>Example</title>
# ten minute TTL<br/>
WebKdcTokenMaxTTL 10m
</example>

</usage>
</directivesynopsis>

<directivesynopsis>
<name>WebKdcKeyring</name>
<description>Name of the file containing the WebKDC's keyring</description>
<syntax>WebKdcKeyring <em>path</em></syntax>
<default>(none)</default>
<contextlist>
  <context>server config</context>
  <context>virtual host</context>
</contextlist>

<usage>

<p>This is the name of the file containing the WebKDC's keyring, which
stores the server's private AES keys.  The keyring file is read on startup
and cached for the duration of an Apache child process, so if it is
changed by an external process (<code>wa_keyring</code>, for instance),
Apache must be told to reload configuration files in order to pick up the
change.</p>

<p>If the path is not absolute, it will considered relative to
<directive>ServerRoot</directive>.</p>

<note><title>Note</title>
  <p>This directive must be set.</p>
</note>

<example><title>Example</title>
WebKdcKeyring conf/webkdc/keyring
</example>

</usage>
</directivesynopsis>

<directivesynopsis>
<name>WebKdcTokenAcl</name>
<description>Name of the file containing the token ACL</description>
<syntax>WebKdcTokenAcl <em>path</em></syntax>
<default>(none)</default>
<contextlist>
  <context>server config</context>
  <context>virtual host</context>
</contextlist>

<usage>

<p>This is the name of the file containing the ACL that controls access to
who can request tokens.  Each line that isn't blank or starting with
<code>#</code> specifies a type of token that the given Kerberos principal
may request.</p>

<p>The first space-separated field of each line is an identifier (at
present, always a Kerberos principal) which may contain <code>*</code> as
a wildcard.  The second field is either <code>id</code>, saying that this
Kerberos principal may request id tokens (giving the authenticated
identity of the user), or <code>cred</code>, saying that this principal
may request credentials allowing it to act as the user.  For type
<code>cred</code>, there are two more fields, one giving the type (always
<code>krb5</code> for now) and the other giving the Kerberos service
ticket that may be requested.</p>

<example><title>Example ACL File</title>
<pre>
# allow anyone with a webauth keytab to request id tokens
krb5:webauth/*@stanford.edu id
# allow shred to request a service/foobar credential
krb5:webauth/shred.stanford.edu@stanford.edu cred krb5 service/foobar@stanford.edu
</pre>
</example>

<p>The <code>krb5:</code> prefix on the subject is used to signify that
the named principal was authenticated using Kerberos.  Currently, krb5 is
the only supported mechanism for WebAuth servers to initially authenticate
with the WebKDC.  Other types of authentication maybe supported in the
future.</p>

<p>If the path is not absolute, it will be considered relative to
<directive>ServerRoot</directive>.</p>

<note><title>Note</title>
  <p>This directive must be set.</p>

  <p>The ACL file is cached in memory, but will be re-read automatically if
     the modification timestamp on the file changes.</p>
</note>

<example><title>Example</title>
WebKdcTokenAcl conf/webkdc/token.acl
</example>

</usage>
</directivesynopsis>

<directivesynopsis>
<name>WebKdcKeytab</name>
<description>Name of the Kerberos V5 keytab file</description>
<syntax>WebKdcKeytab <em>path</em> [<em>principal</em>]</syntax>
<default>(none)</default>
<contextlist>
  <context>server config</context>
  <context>virtual host</context>
</contextlist>

<usage>

<p>This is the name of the Kerberos V5 keytab file, used by the WebKDC to
authenticate initial requests from application servers.  The principal is
optional and can be used to specify a particular principal in a keytab
file that contains several.  If it is not specified, then the first
principal in the keytab file be used.</p>

<p>If the path is not absolute, it will considered relative to
<directive>ServerRoot</directive>.</p>

<note><title>Note</title>
  <p>This directive must be set.</p>
</note>

<example><title>Example</title>
WebKdcKeytab conf/webkdc/keytab service/webkdc
</example>

</usage>
</directivesynopsis>

<directivesynopsis>
<name>WebKdcLocalRealms</name>
<description>Realms to be stripped from authenticated identities</description>
<syntax>WebKdcLocalRealms none|local|<em>realm</em> ...</syntax>
<default>WebKdcLocalRealms local</default>
<contextlist>
  <context>server config</context>
  <context>virtual host</context>
</contextlist>

<usage>

<p>This directive controls stripping realm qualifications from the
authenticated identity of a WebAuth user.  The realm is defined as the
portion of the authenticated identity following the first unescaped
<code>@</code> in the identity.</p>

<p>If set to <code>none</code>, no transformations are done and the
authenticated identity is always passed in its fully-qualified form.  This
is probably the best option for sites that use multiple local Kerberos
realms where none is the logical default realm.</p>

<p>If set to <code>local</code> (the default), the authenticated identity
will be passed to the krb5_aname_to_localname function on the WebKDC.
Normally, this will strip off the realm if it matches the default Kerberos
realm of the WebKDC (not the requesting WebAuth Application Server) and
otherwise leave it; however, more complex canonicalization rules may be
specified in the <code>/etc/krb5.conf</code> file on the WebKDC.</p>

<p>Otherwise, the space-separated arguments to this directive are taken to
be realms that should be stripped from the authenticated identity.  The
realms must be given in escaped form in the WebKDC configuration (for
example, any <code>@</code> in a realm must be given as
<code>\@</code>).</p>

<note><title>Note</title>
  <p>The canonicalization done is that specified on the WebKDC, not in the
  WebAuth Application Server.  There is no way to perform different
  authenticated identity canonicalization on different WebAuth Application
  Servers using the same WebKDC.</p>
</note>

<example><title>Example</title>
# Strip stanford.edu and WIN.STANFORD.EDU but leave other realms
WebKdcLocalRealms stanford.edu WIN.STANFORD.EDU
</example>

</usage>
</directivesynopsis>

<directivesynopsis>
<name>WebKdcPermittedRealms</name>
<description>List of permitted authentication realms</description>
<syntax>WebKdcPermittedRealms <em>realm</em> ...</syntax>
<default>(none)</default>
<contextlist>
  <context>server config</context>
  <context>virtual host</context>
</contextlist>

<usage>

<p>By default, the WebKDC allows authentication via any realm with which
there is cross-realm trust.  If this directive is given, it restricts
authentication to principals in one of the realms listed in this
directive.  The realms must be given in escaped form in the WebKDC
configuration (for example, any <code>@</code> in a realm must be given as
<code>\@</code>).</p>

<example><title>Example</title>
WebKdcPermittedRealms stanford.edu WIN.STANFORD.EDU
</example>

</usage>
</directivesynopsis>

<directivesynopsis>
<name>WebKdcProxyTokenLifetime</name>
<description>Lifetime of webkdc-proxy tokens we create</description>
<syntax>WebKdcProxyTokenLifetime <em>nnnn[s|m|h|d|w]</em></syntax>
<default>(lifetime of underlying proxied-credential)</default>
<contextlist>
  <context>server config</context>
  <context>virtual host</context>
</contextlist>

<usage>

<p>This directive controls the lifetime of the webkdc-proxy token (the
main single-sign-on cookie containing the user's proxied credentials).  If
not specified, the lifetime time used is the expiration time of the
underlying credential (i.e., the lifetime of the Kerberos TGT for
example).</p>

<p>Tokens created with a webkdc-proxy token (id, proxy, cred) will have
the same expiration time as the webkdc-proxy token, so this directive also
controls the lifetime of those tokens as well.</p>

<p>The units for the time are specified by appending a single letter.
This letter may be one of <code>s</code>, <code>m</code>, <code>h</code>,
<code>d</code>, or <code>w</code>, which correspond to seconds, minutes,
hours, days, and weeks, respectively.</p>

<note><title>Note</title>
  <p>The upper bound of the webkdc-proxy token is always bounded by the
  expiration time of the underlying proxied credential.  For example, if
  the Kerberos V5 TGT expires in 25 hours, then the WebKDC will not create
  a webkdc-proxy token with a lifetime greater then 25 hours, even if this
  directive is set higher then 25 hours.</p>
</note>

<example><title>Example</title>
# create a webkdc-proxy token valid for 2 hours<br/>
WebKdcProxyTokenLifetime 2h
</example>

</usage>
</directivesynopsis>

<directivesynopsis>
<name>WebKdcServiceTokenLifetime</name>
<description>Lifetime of webkdc-service tokens we create</description>
<syntax>WebKdcServiceTokenLifetime <em>nnnn[s|m|h|d|w]</em></syntax>
<default>(none)</default>
<contextlist>
  <context>server config</context>
  <context>virtual host</context>
</contextlist>

<usage>

<p>This directive controls the lifetime of the webkdc-service token we
create.  This controls how often a WebAuth application server needs to
re-authenticate with the WebKDC to get a new service token.  The lifetime
of the service token (and the webkdc-proxy-token) control how often the
WebKDC can change its private key, and how long it should retain the
previous key for.</p>

<p>A reasonable setting for this directive is 30 days, with the private
key of the WebKDC being changed every 60 days or so, keeping the previous
WebKDC private key around for 30 days after it expires.</p>

<p>The units for the time are specified by appending a single letter.
This letter may be one of <code>s</code>, <code>m</code>, <code>h</code>,
<code>d</code>, or <code>w</code>, which correspond to seconds, minutes,
hours, days, and weeks, respectively.</p>

<note><title>Note</title>
  <p>This directive must be set.</p>
</note>

<example><title>Example</title>
# create a webkdc-service token valid for 30 days<br/>
WebKdcServiceTokenLifetime 30d
</example>

</usage>
</directivesynopsis>

<directivesynopsis>
<name>WebKdcDebug</name>
<description>Turn on extra debugging in the Apache error log</description>
<syntax>WebKdcDebug on|off</syntax>
<default>WebKdcDebug off</default>
<contextlist>
  <context>server config</context>
  <context>virtual host</context>
</contextlist>

<usage>

<p>Whether or not to log additional debugging messages to the Apache
server log.</p>

<example><title>Example</title>
WebKdcDebug on
</example>

</usage>
</directivesynopsis>

<directivesynopsis>
<name>WebKdcKeyringAutoUpdate</name>
<description>Whether or not to auto-update the keyring file</description>
<syntax>WebKdcKeyringAutoUpdate on|off</syntax>
<default>WebKdcKeyringAutoUpdate on</default>
<contextlist>
  <context>server config</context>
  <context>virtual host</context>
</contextlist>

<usage>

<p>This directive controls whether or not we auto-update the keyring file.
This includes creating it if it doesn't exist, generating a new key before
the old key expires, and periodically garbage collecting old keys.  Note
that auto updating only occurs on server startup and restarts.</p>

<note><title>Note</title>
  <p>This directive should be turned off if multiple servers are
  sharing the same keyring file, so that the keyring file can be manually
  updated.  That too may eventually be automated.</p>
</note>

<example><title>Example</title>
WebKdcKeyringAutoUpdate off
</example>

</usage>
</directivesynopsis>

<directivesynopsis>
<name>WebKdcKeyringKeyLifetime</name>
<description>Lifetime of keys in the keyring if we auto-update</description>
<syntax>WebKdcKeyringKeyLifetime <em>nnnn[s|m|h|d|w]</em></syntax>
<default>WebKdcKeyringKeyLifetime 30d</default>
<contextlist>
  <context>server config</context>
  <context>virtual host</context>
</contextlist>

<usage>

<p>This directive controls how long keys we automatically create for the
keyring are valid.  Keys will be valid from the time they are created
until the lifetime is reached.  It is equivalent to the time specified to
<code>wa_keyring gc</code>, except that the latter expects a negative
time.  Note that key lifetime is only checked on server startup and
restarts.</p>

<p>This directive is only consulted if
<a href="#webkdckeyringautoupdate"><directive>WebKdcKeyringAutoUpdate</directive></a>
is enabled.</p>

<p>The units for the time are specified by appending a single letter.
This letter may be one of <code>s</code>, <code>m</code>, <code>h</code>,
<code>d</code>, or <code>w</code>, which correspond to seconds, minutes,
hours, days, and weeks, respectively.</p>

<example><title>Example</title>
WebKdcKeyringKeyLifetime 60d<br/>
</example>

</usage>
</directivesynopsis>
</modulesynopsis>
